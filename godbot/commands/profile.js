const { SlashCommandBuilder, EmbedBuilder, AttachmentBuilder } = require("discord.js");
const fs = require("fs");
const path = require("path");
const { createCanvas } = require("canvas");

const relationship = require("../utils/relationship.js");
const activity = require("../utils/activity-tracker.js");
const activityLogger = require("../utils/activity-logger.js");

const profilesPath = path.join(__dirname, "../data/profiles.json");
const favorPath = path.join(__dirname, "../data/favor.json");
const bePath = path.join(__dirname, "../data/BE.json");

const PLAY_STYLE_ROLES = {
  "Îπ°Í≤úÎü¨": "1210762363704311838",
  "Ï¶êÎπ°Í≤úÎü¨": "1210762298172383273",
  "Ï¶êÍ≤úÎü¨": "1210762420151394354"
};

// üîì ÎπÑÍ≥µÍ∞ú Î¨¥Ïãú Ïó¥Îûå Í∂åÌïú(Í¥ÄÎ¶¨Ïö© Îì±)
const PRIVACY_BYPASS_ROLE_IDS = ["786128824365482025", "1201856430580432906"];

const readJson = p => (fs.existsSync(p) ? JSON.parse(fs.readFileSync(p)) : {});
const formatAmount = n => Number(n ?? 0).toLocaleString("ko-KR");
const formatVoice = sec => {
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  return h ? `${h}ÏãúÍ∞Ñ ${m}Î∂Ñ` : `${m}Î∂Ñ`;
};
const getFavorEmoji = v => (v >= 15 ? "üíñ" : v >= 5 ? "üòä" : v >= 0 ? "ü§ù" : "üí¢");
function getTierEmoji(str = "") {
  const lower = String(str || "").toLowerCase();
  if (!str) return "‚ùî";
  if (str.includes("Ï±åÎ¶∞Ï†Ä") || lower.includes("challenger")) return "üåü";
  if (str.includes("ÎßàÏä§ÌÑ∞") || lower.includes("master")) return "üî±";
  if (str.includes("Îã§Ïù¥ÏïÑ") || lower.includes("diamond")) return "üíé";
  if (str.includes("ÌîåÎûò") || lower.includes("plat")) return "ü•à";
  if (str.includes("Í≥®Îìú") || lower.includes("gold")) return "ü•á";
  if (str.includes("Ïã§Î≤Ñ") || lower.includes("silver")) return "ü•â";
  if (str.includes("Î∏åÎ°†Ï¶à") || lower.includes("bronze")) return "ü•Ñ";
  return "üéÆ";
}
function getPlayStyle(member) {
  if (!member) return "ÎØ∏ÏÑ§Ï†ï";
  for (const [name, id] of Object.entries(PLAY_STYLE_ROLES)) {
    if (member.roles.cache.has(id)) return name;
  }
  return "ÎØ∏ÏÑ§Ï†ï";
}
const toLower = v => String(v || "").toLowerCase();
function isVoiceLog(log) {
  const t = toLower(log.activityType || log.type || log.event || "");
  return t.includes("voice");
}
function isMessageLog(log) {
  const t = toLower(log.activityType || log.type || log.event || "");
  return t.includes("message") || t.includes("chat") || t.includes("text");
}
function pickChannelIdFromLog(log) {
  return (
    log.details?.channelId ||
    log.details?.channel?.id ||
    log.channelId ||
    log.channel?.id ||
    log.details?.voiceChannelId ||
    log.details?.channel_id ||
    null
  );
}
function pickDurationFromLog(log) {
  return (
    log.details?.durationSec ??
    log.durationSec ??
    log.details?.lengthSec ??
    log.lengthSec ??
    0
  );
}
function formatActivityName(log) {
  if (!log) return "";
  if (log.activityType === "game" && log.details?.name) return log.details.name;
  if (toLower(log.activityType) === "music" && log.details?.song) {
    return `üéµ ${log.details.song} - ${log.details.artist || ""}`.trim();
  }
  if ((log.activityType || log.type) && (log.details?.name || log.name)) {
    return `${log.activityType || log.type}: ${log.details?.name || log.name}`;
  }
  return log.activityType || log.type || "ÌôúÎèô";
}
function formatTimeString(ms) {
  const date = new Date(ms + 9 * 60 * 60 * 1000);
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, "0");
  const d = String(date.getDate()).padStart(2, "0");
  const h = String(date.getHours()).padStart(2, "0");
  const mi = String(date.getMinutes()).padStart(2, "0");
  return `${y}-${m}-${d} ${h}:${mi}`;
}
function clamp01(x) {
  return Math.max(0, Math.min(1, x));
}
function dayNightBuckets(hoursObj) {
  let day = 0;
  let night = 0;
  for (let h = 0; h < 24; h++) {
    const hh = String(h).padStart(2, "0");
    const b = hoursObj[hh] || { message: 0, voice: 0 };
    const act = (b.message || 0) + (b.voice || 0) / 60;
    if (h >= 7 && h <= 20) day += act;
    else night += act;
  }
  return { day, night, total: day + night };
}
function buildRadarStats30d(userId) {
  const now = new Date();
  const to = now.toISOString().slice(0, 10);
  const from = new Date(now.getTime() - 29 * 24 * 3600 * 1000).toISOString().slice(0, 10);
  const stat = activity.getStats?.({ from, to, userId })?.[0] || { message: 0, voice: 0 };
  const voiceSec = stat.voice || 0;
  const msgCnt = stat.message || 0;
  const dailyHourly = activity.getDailyHourlyStats?.({ from, to, userId }) || {};
  let dayAct = 0, nightAct = 0, totalAct = 0;
  for (const date of Object.keys(dailyHourly)) {
    const { day, night, total } = dayNightBuckets(dailyHourly[date] || {});
    dayAct += day;
    nightAct += night;
    totalAct += total;
  }
  const last = relationship.loadLastInteraction?.() || {};
  const cutoff = Date.now() - 30 * 24 * 60 * 60 * 1000;
  let distinctUsersCount = 0;
  if (last[userId]) {
    distinctUsersCount = Object.entries(last[userId]).filter(([, t]) => t >= cutoff).length;
  }
  const speakingScore = clamp01(voiceSec / (3600 * 400)) * 100;
  const typingScore = clamp01(msgCnt / 20000) * 100;
  const affinityScore = clamp01(distinctUsersCount / 150) * 100;
  const dayRatio = totalAct > 0 ? (dayAct / totalAct) * 100 : 0;
  const nightRatio = totalAct > 0 ? (nightAct / totalAct) * 100 : 0;
  return {
    labels: ["Ïä§ÌîºÌÇπ", "ÌÉÄÏù¥Ìïë", "ÏπúÌôîÎ†•", "Ï£ºÌñâÏÑ±", "ÏïºÌñâÏÑ±"],
    values: [Math.round(speakingScore), Math.round(typingScore), Math.round(affinityScore), Math.round(dayRatio), Math.round(nightRatio)],
  };
}
function renderRadarPng({ labels, values }) {
  const W = 1100, H = 680;
  const canvas = createCanvas(W, H);
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "#0a2340";
  ctx.fillRect(0, 0, W, H);
  const cx = W * 0.55, cy = H * 0.52;
  const rMax = Math.min(W, H) * 0.40;
  const axisN = 5;
  const angles = [];
  for (let i = 0; i < axisN; i++) angles.push(-Math.PI / 2 + i * (2 * Math.PI / axisN));
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = 1;
  for (let ring = 1; ring <= 5; ring++) {
    const rr = (rMax * ring) / 5;
    ctx.beginPath();
    for (let i = 0; i < axisN; i++) {
      const a = angles[i];
      const x = cx + rr * Math.cos(a);
      const y = cy + rr * Math.sin(a);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
  }
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  for (let i = 0; i < axisN; i++) {
    const a = angles[i];
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + rMax * Math.cos(a), cy + rMax * Math.sin(a));
    ctx.stroke();
  }
  ctx.fillStyle = "#cfe6ff";
  ctx.font = "600 32px Pretendard, Malgun Gothic, sans-serif";
  const labelRadius = rMax + 34;
  for (let i = 0; i < axisN; i++) {
    const a = angles[i];
    const rx = cx + labelRadius * Math.cos(a);
    const ry = cy + labelRadius * Math.sin(a);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(labels[i], rx, ry);
  }
  const pts = values.map((v, i) => {
    const a = angles[i];
    const rr = rMax * (v / 100);
    return [cx + rr * Math.cos(a), cy + rr * Math.sin(a)];
  });
  ctx.beginPath();
  pts.forEach(([x, y], i) => { if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); });
  ctx.closePath();
  ctx.fillStyle = "rgba(93, 183, 255, 0.35)";
  ctx.strokeStyle = "rgba(93, 183, 255, 0.95)";
  ctx.lineWidth = 3;
  ctx.fill();
  ctx.stroke();
  ctx.fillStyle = "#ffffff";
  ctx.font = "bold 18px Pretendard, Malgun Gothic, sans-serif";
  for (let i = 0; i < axisN; i++) {
    const a = angles[i];
    const rr = rMax * (values[i] / 100);
    const x = cx + rr * Math.cos(a);
    const y = cy + rr * Math.sin(a);
    const label = `${values[i]}%`;
    const mw = ctx.measureText(label).width;
    ctx.fillText(label, x - mw / 2, y - 8);
  }
  return canvas.toBuffer("image/png");
}

// ---- Ìè¥Î∞± Ìè¨Ìï®: ÏûêÏ£º ÏÇ¨Ïö©ÌïòÎäî ÏùåÏÑ±Ï±ÑÎÑê(30Ïùº) ----
async function getFavVoiceChannelText(userId, guild, now = new Date()) {
  const to = now.toISOString().slice(0, 10);
  const from = new Date(now.getTime() - 29 * 24 * 3600 * 1000).toISOString().slice(0, 10);

  try {
    if (typeof activity.getVoiceChannelUsage === "function") {
      const stats = activity.getVoiceChannelUsage({ from, to, userId }) || {};
      const top = Object.entries(stats).sort((a, b) => (b[1] || 0) - (a[1] || 0))[0];
      if (top) {
        const [chId, seconds] = top;
        return `<#${chId}> (${formatVoice(seconds || 0)})`;
      }
    }
    if (typeof activity.getVoiceTopChannels === "function") {
      const arr = activity.getVoiceTopChannels({ from, to, userId }) || [];
      if (Array.isArray(arr) && arr.length) {
        const first = arr[0];
        const chId = first.channelId || first[0];
        const seconds = first.seconds || first[1] || 0;
        if (chId) return `<#${chId}> (${formatVoice(seconds)})`;
      }
    }
  } catch {}

  try {
    const logs = activityLogger.getUserActivities?.(userId) || [];
    const cutoff = Date.now() - 30 * 24 * 3600 * 1000;
    const count = {};
    for (const l of logs) {
      if (!l || typeof l.time !== "number" || l.time < cutoff) continue;
      if (!isVoiceLog(l)) continue;
      const chId = pickChannelIdFromLog(l);
      if (!chId) continue;
      const dur = pickDurationFromLog(l);
      const weight = dur > 0 ? Math.max(1, Math.round(dur / 60)) : 1;
      count[chId] = (count[chId] || 0) + weight;
    }
    const top = Object.entries(count).sort((a, b) => b[1] - a[1])[0];
    if (top) {
      return `<#${top[0]}> (Ïù¥Ïö© ÏßÄÏàò ${top[1]}Ï†ê)`;
    }
  } catch {}

  return "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå";
}

// ---- Ìè¥Î∞± Ìè¨Ìï®: ÏûêÏ£º Îì±Ïû•ÌïòÎäî ÏãúÍ∞ÑÎåÄ(30Ïùº, KST) ----
async function getFavTimeRangeText(userId, now = new Date()) {
  const to = now.toISOString().slice(0, 10);
  const from = new Date(now.getTime() - 29 * 24 * 3600 * 1000).toISOString().slice(0, 10);

  try {
    if (typeof activity.getDailyHourlyStats === "function") {
      const dailyHourly = activity.getDailyHourlyStats({ from, to, userId }) || {};
      const hours = {};
      for (let h = 0; h < 24; h++) hours[String(h).padStart(2, "0")] = 0;
      for (const day of Object.keys(dailyHourly)) {
        const byHour = dailyHourly[day] || {};
        for (let h = 0; h < 24; h++) {
          const hh = String(h).padStart(2, "0");
          const b = byHour[hh] || { message: 0, voice: 0 };
          const score = (b.message || 0) + (b.voice || 0) / 60;
          hours[hh] += score;
        }
      }
      const top = Object.entries(hours).sort((a, b) => b[1] - a[1])[0];
      if (top && top[1] > 0) {
        const hour = Number(top[0]);
        return `${hour}Ïãú ~ ${((hour + 1) % 24)}Ïãú`;
      }
    }
  } catch {}

  try {
    if (typeof activity.getHourlyStats === "function") {
      const hourly = activity.getHourlyStats({ from, to, userId }) || {};
      const norm = {};
      for (let h = 0; h < 24; h++) {
        const hh = String(h).padStart(2, "0");
        const v = hourly[hh];
        if (typeof v === "number") norm[hh] = v;
        else {
          const score = (v?.message || 0) + (v?.voice || 0) / 60;
          norm[hh] = score;
        }
      }
      const top = Object.entries(norm).sort((a, b) => (b[1] || 0) - (a[1] || 0))[0];
      if (top && (top[1] || 0) > 0) {
        const hour = Number(top[0]);
        return `${hour}Ïãú ~ ${((hour + 1) % 24)}Ïãú`;
      }
    }
  } catch {}

  try {
    const logs = activityLogger.getUserActivities?.(userId) || [];
    const cutoff = Date.now() - 30 * 24 * 3600 * 1000;
    const hours = new Array(24).fill(0);
    for (const l of logs) {
      if (!l || typeof l.time !== "number" || l.time < cutoff) continue;
      const kst = new Date(l.time + 9 * 3600 * 1000);
      const h = kst.getHours();
      let weight = 1;
      if (isMessageLog(l)) weight += 0.5;
      if (isVoiceLog(l)) {
        const dur = pickDurationFromLog(l);
        if (dur > 0) weight += Math.min(10, Math.round(dur / 300));
        else weight += 1;
      }
      hours[h] += weight;
    }
    const idx = hours.findIndex(v => v === Math.max(...hours));
    if (hours[idx] > 0) return `${idx}Ïãú ~ ${(idx + 1) % 24}Ïãú`;
  } catch {}

  return "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå";
}

function hasAnyRole(member, roleIds = []) {
  if (!member) return false;
  return roleIds.some(rid => member.roles.cache.has(rid));
}

module.exports = {
  data: new SlashCommandBuilder()
    .setName("ÌîÑÎ°úÌïÑ")
    .setDescription("Ïú†Ï†ÄÏùò ÌîÑÎ°úÌïÑÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§.")
    .addUserOption(opt => opt.setName("Ïú†Ï†Ä").setDescription("ÌôïÏù∏Ìï† Ïú†Ï†Ä (ÏûÖÎ†• ÏïàÌïòÎ©¥ Î≥∏Ïù∏)").setRequired(false)),
  async execute(interaction) {
    const target = interaction.options.getUser("Ïú†Ï†Ä") || interaction.user;
    const userId = target.id;

    const profiles = readJson(profilesPath);
    const favor = readJson(favorPath);
    const be = readJson(bePath);

    // Í∏∞Î≥∏ ÌîÑÎ°úÌïÑ + ÎπÑÍ≥µÍ∞ú ÌîåÎûòÍ∑∏ Ìè¥Î∞±
    const defaultProfile = { statusMsg: "", favGames: [], owTier: "", lolTier: "", steamNick: "", lolNick: "", bnetNick: "", isPrivate: false };
    const profile = { ...defaultProfile, ...(profiles[userId] || {}) };

    const viewerId = interaction.user.id;
    const isSelf = viewerId === userId;

    // ÎåÄÏÉÅ/Ïó¥ÎûåÏûê Î©§Î≤Ñ
    const targetMember = await interaction.guild.members.fetch(userId).catch(() => null);
    const viewerMember = interaction.member ?? (await interaction.guild.members.fetch(viewerId).catch(() => null));

    // üîí ÎπÑÍ≥µÍ∞ú Ï≤òÎ¶¨
    if (!isSelf && profile.isPrivate) {
      const canBypass = hasAnyRole(viewerMember, PRIVACY_BYPASS_ROLE_IDS);
      if (!canBypass) {
        await interaction.reply({ content: "Ìï¥Îãπ Ïú†Ï†ÄÎäî ÌîÑÎ°úÌïÑ ÎπÑÍ≥µÍ∞ú ÏÉÅÌÉú ÏûÖÎãàÎã§.", ephemeral: true });
        return;
      }
      // bypass Ïãú ÏïàÎÇ¥Îßå Ï≤®Ïñ∏ÌïòÍ≥† Í≥ÑÏÜç ÏßÑÌñâ
    }

    const playStyle = getPlayStyle(targetMember);
    const favorVal = favor[userId] ?? 0;
    const beAmount = formatAmount(be[userId]?.amount ?? 0);
    const statusMsg = `üó®Ô∏è „Äé${profile.statusMsg?.trim() || "ÏÉÅÌÉú Î©îÏãúÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§."}„Äè`;
    const joinedStr = `<t:${Math.floor((targetMember?.joinedAt || new Date()).getTime() / 1000)}:R>`;

    // ÍµêÎ•ò TOP3
    let friendsStr = "ÏóÜÏùå";
    try {
      const rawTop = relationship?.getTopRelations ? relationship.getTopRelations(userId, 3) : [];
      const names = [];
      for (const rel of rawTop) {
        const fid = typeof rel === "string" ? rel : rel.userId ?? rel.id;
        if (!fid) continue;
        const m = await interaction.guild.members.fetch(fid).catch(() => null);
        if (m) names.push(m.displayName);
        else {
          const u = await interaction.client.users.fetch(fid).catch(() => null);
          names.push(u ? `${u.username} (ÌÉàÏ£º)` : "(ÌÉàÏ£º)");
        }
      }
      if (names.length) friendsStr = names.map(n => `‚Ä¢ ${n}`).join("\n");
    } catch {}

    // ÏµúÍ∑º 7Ïùº Ïà´Ïûê
    let recentMsg = 0, recentVoice = 0;
    try {
      const now = new Date();
      const from = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
      const stat = activity?.getStats ? activity.getStats({ from: from.toISOString().slice(0, 10), to: now.toISOString().slice(0, 10), userId }) : [];
      if (stat?.length) {
        recentMsg = stat[0].message ?? 0;
        recentVoice = stat[0].voice ?? 0;
      }
    } catch {}

    // ÏµúÍ∑º ÌôúÎèô Ïù¥Î†•: 1Í∞úÎßå
    let recentActivitiesStr = "ÏóÜÍ±∞ÎÇò ÌôúÎèô Í≥µÏú†Î•º ÌïòÍ≥† ÏûàÏßÄ ÏïäÏùå";
    try {
      const logs = activityLogger.getUserActivities?.(userId) || [];
      logs.sort((a, b) => (b.time || 0) - (a.time || 0));
      const recentLogs = logs.slice(0, 1);
      if (recentLogs.length) {
        recentActivitiesStr = recentLogs.map(log => `‚Ä¢ ${formatActivityName(log)} [${formatTimeString(log.time)}]`).join("\n");
      }
    } catch {
      recentActivitiesStr = "Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®";
    }

    const favVoiceChannel = await getFavVoiceChannelText(userId, interaction.guild).catch(() => "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå");
    const favTimeRange = await getFavTimeRangeText(userId).catch(() => "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå");

    // Î†àÏù¥Îçî PNG
    const radar = buildRadarStats30d(userId);
    const png = renderRadarPng(radar);
    const attachment = new AttachmentBuilder(png, { name: "profile-stats.png" });

    // üîî ÎπÑÍ≥µÍ∞ú Ïö∞Ìöå Ïó¥Îûå ÏïàÎÇ¥ Î¨∏Íµ¨ Íµ¨ÏÑ±
    const privacyNotice =
      (!isSelf && profile.isPrivate && hasAnyRole(viewerMember, PRIVACY_BYPASS_ROLE_IDS))
        ? "‚ö†Ô∏è Ìï¥Îãπ Ïú†Ï†ÄÎäî ÌîÑÎ°úÌïÑ ÎπÑÍ≥µÍ∞úÎ•º ÏÑ§Ï†ïÌïú Ïú†Ï†ÄÏûÖÎãàÎã§.\n"
        : "";

    const embed = new EmbedBuilder()
      .setTitle("ÌîÑÎ°úÌïÑ Ï†ïÎ≥¥")
      .setThumbnail(target.displayAvatarURL())
      .setColor(favorVal >= 15 ? 0xff71b3 : favorVal >= 5 ? 0x82d8ff : 0xbcbcbc)
      .setDescription([
        privacyNotice + `<@${userId}> ÎãòÏùò ÌîÑÎ°úÌïÑ`,
        statusMsg,
        `üî∑ ÌååÎûë Ï†ïÏàò(BE): **${beAmount} BE**`
      ].join("\n"))
      .addFields(
        { name: "üéÆ ÌîåÎ†àÏù¥ Ïä§ÌÉÄÏùº", value: playStyle, inline: true },
        { name: `${getFavorEmoji(favorVal)} Ìò∏Í∞êÎèÑ`, value: String(favorVal), inline: true },
        { name: "‚è∞ ÏÑúÎ≤Ñ ÏûÖÏû•", value: joinedStr, inline: true },
        { name: "üé≤ ÏÑ†Ìò∏ Í≤åÏûÑ", value: profile.favGames.length ? profile.favGames.map(g => `‚Ä¢ ${g}`).join("\n") : "ÏóÜÏùå", inline: false },
        { name: "üü† Ïò§Î≤ÑÏõåÏπò", value: `${getTierEmoji(profile.owTier)} ${profile.owTier || "ÏóÜÏùå"}`, inline: true },
        { name: "üîµ Î°§", value: `${getTierEmoji(profile.lolTier)} ${profile.lolTier || "ÏóÜÏùå"}`, inline: true },
        { name: "üíª Ïä§ÌåÄ", value: profile.steamNick || "ÏóÜÏùå", inline: true },
        { name: "üîñ Î°§ ÎãâÎÑ§ÏûÑ", value: profile.lolNick || "ÏóÜÏùå", inline: true },
        { name: "üü¶ Î∞∞ÌãÄÎÑ∑", value: profile.bnetNick || "ÏóÜÏùå", inline: true },
        { name: "ü§ó ÍµêÎ•òÍ∞Ä ÌôúÎ∞úÌïú 3Ïù∏", value: friendsStr, inline: false },
        { name: "üìä ÏµúÍ∑º 7Ïùº Ï±ÑÌåÖ", value: `${recentMsg}Ìöå`, inline: true },
        { name: "üîä ÏµúÍ∑º 7Ïùº ÏùåÏÑ±", value: formatVoice(recentVoice), inline: true },
        { name: "üìù ÏµúÍ∑º ÌôúÎèô Ïù¥Î†•", value: recentActivitiesStr, inline: false },
        { name: "üé§ ÏûêÏ£º ÏÇ¨Ïö©ÌïòÎäî ÏùåÏÑ±Ï±ÑÎÑê", value: favVoiceChannel, inline: false },
        { name: "‚è±Ô∏è ÏûêÏ£º Îì±Ïû•ÌïòÎäî ÏãúÍ∞ÑÎåÄ", value: favTimeRange, inline: false }
      )
      .setImage("attachment://profile-stats.png")
      .setFooter({
        text: userId === interaction.user.id ? "/ÌîÑÎ°úÌïÑÎì±Î°ù /ÌîÑÎ°úÌïÑÏàòÏ†ï ÏùÑ ÌÜµÌï¥ ÌîÑÎ°úÌïÑÏùÑ Î≥¥Í∞ïÌïòÏÑ∏Ïöî!" : "ÌòÅÏã†Ï†Å Ï¢ÖÌï©Í≤åÏûÑÏÑúÎ≤Ñ, ÍπåÎ¶¨ÌïúÎîîÏä§ÏΩîÎìú",
        iconURL: interaction.client.user.displayAvatarURL()
      });

    await interaction.reply({ embeds: [embed], files: [attachment], ephemeral: true });
  }
};
