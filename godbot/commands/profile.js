const { SlashCommandBuilder, EmbedBuilder, AttachmentBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ComponentType } = require("discord.js");
const fs = require("fs");
const path = require("path");
const { createCanvas } = require("canvas");

const relationship = require("../utils/relationship.js");
const activity = require("../utils/activity-tracker.js");
const activityLogger = require("../utils/activity-logger.js");

const profilesPath = path.join(__dirname, "../data/profiles.json");
const favorPath = path.join(__dirname, "../data/favor.json");
const bePath = path.join(__dirname, "../data/BE.json");

const PLAY_STYLE_ROLES = {
  "Îπ°Í≤úÎü¨": "1210762363704311838",
  "Ï¶êÎπ°Í≤úÎü¨": "1210762298172383273",
  "Ï¶êÍ≤úÎü¨": "1210762420151394354"
};

const PRIVACY_BYPASS_ROLE_IDS = ["786128824365482025", "1201856430580432906"];

const readJson = p => (fs.existsSync(p) ? JSON.parse(fs.readFileSync(p)) : {});
const formatAmount = n => Number(n ?? 0).toLocaleString("ko-KR");
const formatVoice = sec => {
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  return h ? `${h}ÏãúÍ∞Ñ ${m}Î∂Ñ` : `${m}Î∂Ñ`;
};
const getFavorEmoji = v => (v >= 15 ? "üíñ" : v >= 5 ? "üòä" : v >= 0 ? "ü§ù" : "üí¢");
function getTierEmoji(str = "") {
  const lower = String(str || "").toLowerCase();
  if (!str) return "‚ùî";
  if (str.includes("Ï±åÎ¶∞Ï†Ä") || lower.includes("challenger")) return "üåü";
  if (str.includes("ÎßàÏä§ÌÑ∞") || lower.includes("master")) return "üî±";
  if (str.includes("Îã§Ïù¥ÏïÑ") || lower.includes("diamond")) return "üíé";
  if (str.includes("ÌîåÎûò") || lower.includes("plat")) return "ü•à";
  if (str.includes("Í≥®Îìú") || lower.includes("gold")) return "ü•á";
  if (str.includes("Ïã§Î≤Ñ") || lower.includes("silver")) return "ü•â";
  if (str.includes("Î∏åÎ°†Ï¶à") || lower.includes("bronze")) return "ü•Ñ";
  return "üéÆ";
}
function getPlayStyle(member) {
  if (!member) return "ÎØ∏ÏÑ§Ï†ï";
  for (const [name, id] of Object.entries(PLAY_STYLE_ROLES)) {
    if (member.roles.cache.has(id)) return name;
  }
  return "ÎØ∏ÏÑ§Ï†ï";
}
const toLower = v => String(v || "").toLowerCase();
function isVoiceLog(log) {
  const t = toLower(log.activityType || log.type || log.event || "");
  return t.includes("voice");
}
function isMessageLog(log) {
  const t = toLower(log.activityType || log.type || log.event || "");
  return t.includes("message") || t.includes("chat") || t.includes("text");
}
function pickChannelIdFromLog(log) {
  return (
    log.details?.channelId ||
    log.details?.channel?.id ||
    log.channelId ||
    log.channel?.id ||
    log.details?.voiceChannelId ||
    log.details?.channel_id ||
    null
  );
}
function pickDurationFromLog(log) {
  return (
    log.details?.durationSec ??
    log.durationSec ??
    log.details?.lengthSec ??
    log.lengthSec ??
    0
  );
}
function formatActivityName(log) {
  if (!log) return "";
  if (log.activityType === "game" && log.details?.name) return log.details.name;
  if (toLower(log.activityType) === "music" && log.details?.song) {
    return `üéµ ${log.details.song} - ${log.details.artist || ""}`.trim();
  }
  if ((log.activityType || log.type) && (log.details?.name || log.name)) {
    return `${log.activityType || log.type}: ${log.details?.name || log.name}`;
  }
  return log.activityType || log.type || "ÌôúÎèô";
}
function formatTimeString(ms) {
  const date = new Date(ms + 9 * 60 * 60 * 1000);
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, "0");
  const d = String(date.getDate()).padStart(2, "0");
  const h = String(date.getHours()).padStart(2, "0");
  const mi = String(date.getMinutes()).padStart(2, "0");
  return `${y}-${m}-${d} ${h}:${mi}`;
}
function clamp01(x) {
  return Math.max(0, Math.min(1, x));
}
function dayNightBuckets(hoursObj) {
  let day = 0;
  let night = 0;
  for (let h = 0; h < 24; h++) {
    const hh = String(h).padStart(2, "0");
    const b = hoursObj[hh] || { message: 0, voice: 0 };
    const act = (b.message || 0) + (b.voice || 0) / 60;
    if (h >= 7 && h <= 20) day += act;
    else night += act;
  }
  return { day, night, total: day + night };
}
function buildRadarStats30d(userId) {
  const now = new Date();
  const to = now.toISOString().slice(0, 10);
  const from = new Date(now.getTime() - 29 * 24 * 3600 * 1000).toISOString().slice(0, 10);
  const stat = activity.getStats?.({ from, to, userId })?.[0] || { message: 0, voice: 0 };
  const voiceSec = stat.voice || 0;
  const msgCnt = stat.message || 0;
  const dailyHourly = activity.getDailyHourlyStats?.({ from, to, userId }) || {};
  let dayAct = 0, nightAct = 0, totalAct = 0;
  for (const date of Object.keys(dailyHourly)) {
    const { day, night, total } = dayNightBuckets(dailyHourly[date] || {});
    dayAct += day;
    nightAct += night;
    totalAct += total;
  }
  const last = relationship.loadLastInteraction?.() || {};
  const cutoff = Date.now() - 30 * 24 * 60 * 60 * 1000;
  let distinctUsersCount = 0;
  if (last[userId]) {
    distinctUsersCount = Object.entries(last[userId]).filter(([, t]) => t >= cutoff).length;
  }
  const speakingScore = clamp01(voiceSec / (3600 * 360)) * 100;
  const typingScore = clamp01(msgCnt / 15000) * 100;
  const affinityScore = clamp01(distinctUsersCount / 130) * 100;
  const dayRatio = totalAct > 0 ? (dayAct / totalAct) * 100 : 0;
  const nightRatio = totalAct > 0 ? (nightAct / totalAct) * 100 : 0;
  return {
    labels: ["Ïä§ÌîºÌÇπ", "Ï±ÑÌåÖ", "Ìè¨Ïö©Î†•", "Ï£ºÍ∞ÑÌòï", "ÏïºÍ∞ÑÌòï"],
    values: [Math.round(speakingScore), Math.round(typingScore), Math.round(affinityScore), Math.round(dayRatio), Math.round(nightRatio)],
  };
}
function renderRadarPng({ labels, values }) {
  const W = 1100, H = 680;
  const canvas = createCanvas(W, H);
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "#0a2340";
  ctx.fillRect(0, 0, W, H);
  const cx = W * 0.55, cy = H * 0.52;
  const rMax = Math.min(W, H) * 0.40;
  const axisN = 5;
  const angles = [];
  for (let i = 0; i < axisN; i++) angles.push(-Math.PI / 2 + i * (2 * Math.PI / axisN));
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = 1;
  for (let ring = 1; ring <= 5; ring++) {
    const rr = (rMax * ring) / 5;
    ctx.beginPath();
    for (let i = 0; i < axisN; i++) {
      const a = angles[i];
      const x = cx + rr * Math.cos(a);
      const y = cy + rr * Math.sin(a);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
  }
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  for (let i = 0; i < axisN; i++) {
    const a = angles[i];
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + rMax * Math.cos(a), cy + rMax * Math.sin(a));
    ctx.stroke();
  }
  ctx.fillStyle = "#cfe6ff";
  ctx.font = "600 32px Pretendard, Malgun Gothic, sans-serif";
  const labelRadius = rMax + 34;
  for (let i = 0; i < axisN; i++) {
    const a = angles[i];
    const rx = cx + labelRadius * Math.cos(a);
    const ry = cy + labelRadius * Math.sin(a);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(labels[i], rx, ry);
  }
  const pts = values.map((v, i) => {
    const a = angles[i];
    const rr = rMax * (v / 100);
    return [cx + rr * Math.cos(a), cy + rr * Math.sin(a)];
  });
  ctx.beginPath();
  pts.forEach(([x, y], i) => { if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); });
  ctx.closePath();
  ctx.fillStyle = "rgba(93, 183, 255, 0.35)";
  ctx.strokeStyle = "rgba(93, 183, 255, 0.95)";
  ctx.lineWidth = 3;
  ctx.fill();
  ctx.stroke();
  ctx.fillStyle = "#ffffff";
  ctx.font = "bold 18px Pretendard, Malgun Gothic, sans-serif";
  for (let i = 0; i < axisN; i++) {
    const a = angles[i];
    const rr = rMax * (values[i] / 100);
    const x = cx + rr * Math.cos(a);
    const y = cy + rr * Math.sin(a);
    const label = `${values[i]}%`;
    const mw = ctx.measureText(label).width;
    ctx.fillText(label, x - mw / 2, y - 8);
  }
  return canvas.toBuffer("image/png");
}

async function getFavVoiceChannelText(userId, guild, now = new Date()) {
  const to = now.toISOString().slice(0, 10);
  const from = new Date(now.getTime() - 29 * 24 * 3600 * 1000).toISOString().slice(0, 10);
  try {
    if (typeof activity.getVoiceChannelUsage === "function") {
      const stats = activity.getVoiceChannelUsage({ from, to, userId }) || {};
      const top = Object.entries(stats).sort((a, b) => (b[1] || 0) - (a[1] || 0))[0];
      if (top) {
        const [chId, seconds] = top;
        return `<#${chId}> (${formatVoice(seconds || 0)})`;
      }
    }
    if (typeof activity.getVoiceTopChannels === "function") {
      const arr = activity.getVoiceTopChannels({ from, to, userId }) || [];
      if (Array.isArray(arr) && arr.length) {
        const first = arr[0];
        const chId = first.channelId || first[0];
        const seconds = first.seconds || first[1] || 0;
        if (chId) return `<#${chId}> (${formatVoice(seconds)})`;
      }
    }
  } catch {}
  try {
    const logs = activityLogger.getUserActivities?.(userId) || [];
    const cutoff = Date.now() - 30 * 24 * 3600 * 1000;
    const count = {};
    for (const l of logs) {
      if (!l || typeof l.time !== "number" || l.time < cutoff) continue;
      if (!isVoiceLog(l)) continue;
      const chId = pickChannelIdFromLog(l);
      if (!chId) continue;
      const dur = pickDurationFromLog(l);
      const weight = dur > 0 ? Math.max(1, Math.round(dur / 60)) : 1;
      count[chId] = (count[chId] || 0) + weight;
    }
    const top = Object.entries(count).sort((a, b) => b[1] - a[1])[0];
    if (top) {
      return `<#${top[0]}> (Ïù¥Ïö© ÏßÄÏàò ${top[1]}Ï†ê)`;
    }
  } catch {}
  return "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå";
}

async function getFavTimeRangeText(userId, now = new Date()) {
  const to = now.toISOString().slice(0, 10);
  const from = new Date(now.getTime() - 29 * 24 * 3600 * 1000).toISOString().slice(0, 10);
  const topHourLabel = (hoursMap) => {
    const top = Object.entries(hoursMap).sort((a, b) => (b[1] || 0) - (a[1] || 0))[0];
    if (!top || (top[1] || 0) <= 0) return "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå";
    const hour = Number(top[0]);
    return `${hour}Ïãú ~ ${((hour + 1) % 24)}Ïãú`;
  };
  const isWeekday = (d) => {
    const day = d.getDay();
    return day >= 1 && day <= 5;
  };
  const isWeekend = (d) => {
    const day = d.getDay();
    return day === 0 || day === 6;
  };
  const emptyHours = () => {
    const obj = {};
    for (let h = 0; h < 24; h++) obj[String(h).padStart(2, "0")] = 0;
    return obj;
  };
  try {
    if (typeof activity.getDailyHourlyStats === "function") {
      const dailyHourly = activity.getDailyHourlyStats({ from, to, userId }) || {};
      const weekdayHours = emptyHours();
      const weekendHours = emptyHours();
      for (const dateStr of Object.keys(dailyHourly)) {
        const dateKst = new Date(`${dateStr}T00:00:00+09:00`);
        const byHour = dailyHourly[dateStr] || {};
        const bucketTarget = isWeekday(dateKst) ? weekdayHours : isWeekend(dateKst) ? weekendHours : null;
        if (!bucketTarget) continue;
        for (let h = 0; h < 24; h++) {
          const hh = String(h).padStart(2, "0");
          const b = byHour[hh] || { message: 0, voice: 0 };
          const score = (b.message || 0) + (b.voice || 0) / 60;
          bucketTarget[hh] += score;
        }
      }
      const weekdayRange = topHourLabel(weekdayHours);
      const weekendRange = topHourLabel(weekendHours);
      return `ÌèâÏùº: ${weekdayRange}\nÏ£ºÎßê: ${weekendRange}`;
    }
  } catch {}
  try {
    const logs = activityLogger.getUserActivities?.(userId) || [];
    const cutoff = Date.now() - 30 * 24 * 3600 * 1000;
    const weekdayArr = new Array(24).fill(0);
    const weekendArr = new Array(24).fill(0);
    for (const l of logs) {
      if (!l || typeof l.time !== "number" || l.time < cutoff) continue;
      const kst = new Date(l.time + 9 * 3600 * 1000);
      const h = kst.getHours();
      const target = isWeekday(kst) ? weekdayArr : isWeekend(kst) ? weekendArr : null;
      if (!target) continue;
      let weight = 1;
      if (isMessageLog(l)) weight += 0.5;
      if (isVoiceLog(l)) {
        const dur = pickDurationFromLog(l);
        if (dur > 0) weight += Math.min(10, Math.round(dur / 300));
        else weight += 1;
      }
      target[h] += weight;
    }
    const arrTopLabel = (arr) => {
      const max = Math.max(...arr);
      if (!isFinite(max) || max <= 0) return "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå";
      const idx = arr.findIndex(v => v === max);
      return `${idx}Ïãú ~ ${(idx + 1) % 24}Ïãú`;
    };
    const weekdayRange = arrTopLabel(weekdayArr);
    const weekendRange = arrTopLabel(weekendArr);
    return `ÌèâÏùº: ${weekdayRange}\nÏ£ºÎßê: ${weekendRange}`;
  } catch {}
  return "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå";
}

function hasAnyRole(member, roleIds = []) {
  if (!member) return false;
  return roleIds.some(rid => member.roles.cache.has(rid));
}

async function buildProfileView(interaction, targetUser) {
  const userId = targetUser.id;
  const profiles = readJson(profilesPath);
  const favor = readJson(favorPath);
  const be = readJson(bePath);
  const defaultProfile = { statusMsg: "", favGames: [], owTier: "", lolTier: "", steamNick: "", lolNick: "", bnetNick: "", isPrivate: false };
  const profile = { ...defaultProfile, ...(profiles[userId] || {}) };
  const viewerId = interaction.user.id;
  const isSelf = viewerId === userId;
  const targetMember = await interaction.guild.members.fetch(userId).catch(() => null);
  const viewerMember = interaction.member ?? (await interaction.guild.members.fetch(viewerId).catch(() => null));
  if (!isSelf && profile.isPrivate) {
    const canBypass = hasAnyRole(viewerMember, PRIVACY_BYPASS_ROLE_IDS);
    if (!canBypass) {
      return { ephemeral: true, content: "Ìï¥Îãπ Ïú†Ï†ÄÎäî ÌîÑÎ°úÌïÑ ÎπÑÍ≥µÍ∞ú ÏÉÅÌÉú ÏûÖÎãàÎã§." };
    }
  }
  const playStyle = getPlayStyle(targetMember);
  const favorVal = favor[userId] ?? 0;
  const beAmount = formatAmount(be[userId]?.amount ?? 0);
  const statusMsg = `üó®Ô∏è „Äé${profile.statusMsg?.trim() || "ÏÉÅÌÉú Î©îÏãúÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§."}„Äè`;
  const joinedStr = `<t:${Math.floor((targetMember?.joinedAt || new Date()).getTime() / 1000)}:R>`;
  let friendsStr = "ÏóÜÏùå";
  try {
    const rawTop = relationship?.getTopRelations ? relationship.getTopRelations(userId, 3) : [];
    const names = [];
    for (const rel of rawTop) {
      const fid = typeof rel === "string" ? rel : rel.userId ?? rel.id;
      if (!fid) continue;
      const m = await interaction.guild.members.fetch(fid).catch(() => null);
      if (m) names.push(m.displayName);
      else {
        const u = await interaction.client.users.fetch(fid).catch(() => null);
        names.push(u ? `${u.username} (ÌÉàÏ£º)` : "(ÌÉàÏ£º)");
      }
    }
    if (names.length) friendsStr = names.map(n => `‚Ä¢ ${n}`).join("\n");
  } catch {}
  let recentMsg = 0, recentVoice = 0;
  try {
    const now = new Date();
    const from = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const stat = activity?.getStats ? activity.getStats({ from: from.toISOString().slice(0, 10), to: now.toISOString().slice(0, 10), userId }) : [];
    if (stat?.length) {
      recentMsg = stat[0].message ?? 0;
      recentVoice = stat[0].voice ?? 0;
    }
  } catch {}
  let recentActivitiesStr = "ÏóÜÍ±∞ÎÇò ÌôúÎèô Í≥µÏú†Î•º ÌïòÍ≥† ÏûàÏßÄ ÏïäÏùå";
  try {
    const logs = activityLogger.getUserActivities?.(userId) || [];
    logs.sort((a, b) => (b.time || 0) - (a.time || 0));
    const recentLogs = logs.slice(0, 1);
    if (recentLogs.length) {
      recentActivitiesStr = recentLogs.map(log => `‚Ä¢ ${formatActivityName(log)} [${formatTimeString(log.time)}]`).join("\n");
    }
  } catch {
    recentActivitiesStr = "Î∂àÎü¨Ïò§Í∏∞ Ïã§Ìå®";
  }
  const favVoiceChannel = await getFavVoiceChannelText(userId, interaction.guild).catch(() => "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå");
  const favTimeRange = await getFavTimeRangeText(userId).catch(() => "Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå");
  const radar = buildRadarStats30d(userId);
  const png = renderRadarPng(radar);
  const attachment = new AttachmentBuilder(png, { name: "profile-stats.png" });
  const privacyNotice =
    (!isSelf && profile.isPrivate && hasAnyRole(viewerMember, PRIVACY_BYPASS_ROLE_IDS))
      ? "‚ö†Ô∏è Ìï¥Îãπ Ïú†Ï†ÄÎäî ÌîÑÎ°úÌïÑ ÎπÑÍ≥µÍ∞úÎ•º ÏÑ§Ï†ïÌïú Ïú†Ï†ÄÏûÖÎãàÎã§.\n"
      : "";
  const embed = new EmbedBuilder()
    .setTitle("ÌîÑÎ°úÌïÑ Ï†ïÎ≥¥")
    .setThumbnail(targetUser.displayAvatarURL())
    .setColor(favorVal >= 15 ? 0xff71b3 : favorVal >= 5 ? 0x82d8ff : 0xbcbcbc)
    .setDescription([
      privacyNotice + `<@${userId}> ÎãòÏùò ÌîÑÎ°úÌïÑ`,
      statusMsg,
      `üî∑ ÌååÎûë Ï†ïÏàò(BE): **${beAmount} BE**`
    ].join("\n"))
    .addFields(
      { name: "üéÆ ÌîåÎ†àÏù¥ Ïä§ÌÉÄÏùº", value: playStyle, inline: true },
      { name: `${getFavorEmoji(favorVal)} Ìò∏Í∞êÎèÑ`, value: String(favorVal), inline: true },
      { name: "‚è∞ ÏÑúÎ≤Ñ ÏûÖÏû•", value: joinedStr, inline: true },
      { name: "üé≤ ÏÑ†Ìò∏ Í≤åÏûÑ", value: profile.favGames.length ? profile.favGames.map(g => `‚Ä¢ ${g}`).join("\n") : "ÏóÜÏùå", inline: false },
      { name: "üü† Ïò§Î≤ÑÏõåÏπò", value: `${getTierEmoji(profile.owTier)} ${profile.owTier || "ÏóÜÏùå"}`, inline: true },
      { name: "üîµ Î°§", value: `${getTierEmoji(profile.lolTier)} ${profile.lolTier || "ÏóÜÏùå"}`, inline: true },
      { name: "üíª Ïä§ÌåÄ", value: profile.steamNick || "ÏóÜÏùå", inline: true },
      { name: "üîñ Î°§ ÎãâÎÑ§ÏûÑ", value: profile.lolNick || "ÏóÜÏùå", inline: true },
      { name: "üü¶ Î∞∞ÌãÄÎÑ∑", value: profile.bnetNick || "ÏóÜÏùå", inline: true },
      { name: "ü§ó ÍµêÎ•òÍ∞Ä ÌôúÎ∞úÌïú 3Ïù∏", value: friendsStr, inline: false },
      { name: "üìä ÏµúÍ∑º 7Ïùº Ï±ÑÌåÖ", value: `${recentMsg}Ìöå`, inline: true },
      { name: "üîä ÏµúÍ∑º 7Ïùº ÏùåÏÑ±", value: formatVoice(recentVoice), inline: true },
      { name: "üìù ÏµúÍ∑º ÌôúÎèô Ïù¥Î†•", value: recentActivitiesStr, inline: false },
      { name: "üé§ ÏûêÏ£º ÏÇ¨Ïö©ÌïòÎäî ÏùåÏÑ±Ï±ÑÎÑê", value: favVoiceChannel, inline: false },
      { name: "‚è±Ô∏è ÏûêÏ£º Îì±Ïû•ÌïòÎäî ÏãúÍ∞ÑÎåÄ", value: favTimeRange, inline: false }
    )
    .setImage("attachment://profile-stats.png")
    .setFooter({
      text: userId === interaction.user.id ? "/ÌîÑÎ°úÌïÑÎì±Î°ù /ÌîÑÎ°úÌïÑÏàòÏ†ï ÏùÑ ÌÜµÌï¥ ÌîÑÎ°úÌïÑÏùÑ Î≥¥Í∞ïÌïòÏÑ∏Ïöî!" : "ÌòÅÏã†Ï†Å Ï¢ÖÌï©Í≤åÏûÑÏÑúÎ≤Ñ, ÍπåÎ¶¨ÌïúÎîîÏä§ÏΩîÎìú",
      iconURL: interaction.client.user.displayAvatarURL()
    });

  const nav = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId(`goto_be:${userId}`).setLabel("üíô Ï†ïÏàò Î≥¥Í∏∞").setStyle(ButtonStyle.Primary),
    new ButtonBuilder().setCustomId(`goto_profile:${userId}`).setLabel("üë§ ÌîÑÎ°úÌïÑ Î≥¥Í∏∞").setStyle(ButtonStyle.Secondary).setDisabled(true)
  );

  return { embeds: [embed], files: [attachment], components: [nav], ephemeral: true };
}

module.exports = {
  data: new SlashCommandBuilder()
    .setName("ÌîÑÎ°úÌïÑ")
    .setDescription("Ïú†Ï†ÄÏùò ÌîÑÎ°úÌïÑÏùÑ ÌôïÏù∏Ìï©ÎãàÎã§.")
    .addUserOption(opt => opt.setName("Ïú†Ï†Ä").setDescription("ÌôïÏù∏Ìï† Ïú†Ï†Ä (ÏûÖÎ†• ÏïàÌïòÎ©¥ Î≥∏Ïù∏)").setRequired(false)),
  async execute(interaction) {
    const target = interaction.options.getUser("Ïú†Ï†Ä") || interaction.user;
    const view = await buildProfileView(interaction, target);
    if (view.content) return await interaction.reply({ content: view.content, ephemeral: true });
    const msg = await interaction.reply({ embeds: view.embeds, files: view.files, components: view.components, ephemeral: true, fetchReply: true });
    const collector = msg.createMessageComponentCollector({ componentType: ComponentType.Button, time: 300000 });
    collector.on("collect", async i => {
      if (i.user.id !== interaction.user.id) return await i.reply({ content: "Î≥∏Ïù∏Îßå Ï°∞Ïûë Í∞ÄÎä•.", ephemeral: true });
      const [key, uid] = i.customId.split(":");
      const targetUser = await interaction.client.users.fetch(uid).catch(() => null) || interaction.user;
      if (key === "goto_be") {
        const beCheck = require("./be-check.js");
        const beView = await beCheck.buildView(i, targetUser);
        return await i.update({ embeds: beView.embeds, components: beView.components, files: beView.files || [] });
      }
      if (key === "goto_profile") {
        const profView = await buildProfileView(interaction, targetUser);
        return await i.update({ embeds: profView.embeds, components: profView.components, files: profView.files || [] });
      }
    });
    collector.on("end", async () => {
      try { await msg.edit({ components: [] }); } catch {}
    });
  },
  buildView: buildProfileView
};
