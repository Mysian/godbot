const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const fs = require('fs');
const path = require('path');
const lockfile = require('proper-lockfile');

const bePath = path.join(__dirname, '../data/BE.json');
const itemsPath = path.join(__dirname, '../data/items.json');
const skillsPath = path.join(__dirname, '../data/skills.json');
const stockPath = path.join(__dirname, '../data/upgrade-stock.json');
const nicknameRolesPath = path.join(__dirname, '../data/nickname-roles.json');
const titlesPath = path.join(__dirname, '../data/limited-titles.json');
const nickColorStatePath = path.join(__dirname, '../data/nickname-color-states.json');

const NICKNAME_ROLE_PER_USER = 1;
const CHANNEL_ROLE_ID = '1352582997400092755';
const CHANNEL_ROLE_PRICE = 3000000;
const RENT_ROLE_ID = '1352583279102001212';
const RENT_PRICE = 1000000;

const DURATION_OPTIONS = [
  { key: '3d', label: '3Ïùº', seconds: 3 * 24 * 3600, price: 229000 },
  { key: '7d', label: '7Ïùº', seconds: 7 * 24 * 3600, price: 499000 },
  { key: '30d', label: '30Ïùº', seconds: 30 * 24 * 3600, price: 1998000 },
  { key: '100d', label: '100Ïùº', seconds: 100 * 24 * 3600, price: 6251592 },
  { key: '365d', label: '1ÎÖÑ', seconds: 365 * 24 * 3600, price: 19980413 }
];

function numFmt(num) { return num.toLocaleString(); }

const Í∞ïÌôîITEMS = [
  {
    name: 'Î∂àÍµ¥Ïùò ÏòÅÌòº',
    roleId: '1382169247538745404',
    price: 10000,
    desc: 'Ï±îÌîºÏñ∏ Îã®Ïùº Í∞ïÌôî ÏßÑÌñâÏãú Î≥¥Ïú†ÌïòÍ≥† ÏûàÎäî Í≤ΩÏö∞ 100% ÌôïÎ•†Î°ú ÏÜåÎ©∏ÏùÑ Î∞©ÏßÄÌïúÎã§. [1ÌöåÏÑ±/Í≥†Ïú†ÏÉÅÌíà]\n‚Äª 1ÏãúÍ∞ÑÎßàÎã§ Ïû¨Í≥† 1Í∞ú Ï∂©Ï†Ñ [ÏµúÎåÄ 10Í∞ú]',
    emoji: 'üßø',
    key: 'soul',
    period: 1
  },
  {
    name: 'Î∂àÍµ¥Ïùò ÏòÅÌòº (Ï†ÑÏÑ§)',
    roleId: '1382665471605870592',
    price: 50000,
    desc: 'Ï±îÌîºÏñ∏ ÌïúÎ∞© Í∞ïÌôî ÏßÑÌñâÏãú Î≥¥Ïú†ÌïòÍ≥† ÏûàÎäî Í≤ΩÏö∞ 100% ÌôïÎ•†Î°ú ÏÜåÎ©∏ÏùÑ Î∞©ÏßÄÌïúÎã§. [1ÌöåÏÑ±/Í≥†Ïú†ÏÉÅÌíà]\n‚Äª 3ÏãúÍ∞ÑÎßàÎã§ Ïû¨Í≥† 1Í∞ú Ï∂©Ï†Ñ [ÏµúÎåÄ 5Í∞ú]',
    emoji: 'üåü',
    key: 'legendary',
    period: 3
  }
];
const MAX_STOCK = { soul: 10, legendary: 5 };

async function loadJson(p, isArray = false) {
  if (!fs.existsSync(p)) fs.writeFileSync(p, isArray ? "[]" : "{}");
  const release = await lockfile.lock(p, { retries: 3 });
  const data = JSON.parse(fs.readFileSync(p, 'utf8'));
  await release();
  return data;
}
async function saveJson(p, data) {
  const release = await lockfile.lock(p, { retries: 3 });
  fs.writeFileSync(p, JSON.stringify(data, null, 2));
  await release();
}

async function loadStock() {
  if (!fs.existsSync(stockPath)) fs.writeFileSync(stockPath, '{}');
  const release = await lockfile.lock(stockPath, { retries: 3 });
  const data = JSON.parse(fs.readFileSync(stockPath, 'utf8'));
  await release();
  return data;
}
async function saveStock(data) {
  const release = await lockfile.lock(stockPath, { retries: 3 });
  fs.writeFileSync(stockPath, JSON.stringify(data, null, 2));
  await release();
}

async function checkAndRestock(item) {
  const stock = await loadStock();
  const now = Date.now();
  if (!stock[item.key]) stock[item.key] = { stock: 0, last: 0 };
  let changed = false;
  let periodMs = item.period * 60 * 60 * 1000;
  let last = stock[item.key].last || 0;
  let currentStock = stock[item.key].stock || 0;
  if (now - last >= periodMs) {
    const addCount = Math.floor((now - last) / periodMs);
    if (currentStock < MAX_STOCK[item.key]) {
      currentStock = Math.min(MAX_STOCK[item.key], currentStock + addCount);
      stock[item.key].stock = currentStock;
      stock[item.key].last = last + addCount * periodMs;
      changed = true;
    } else if (stock[item.key].last < now - periodMs) {
      stock[item.key].last = now - (now - last) % periodMs;
      changed = true;
    }
  }
  if (changed) await saveStock(stock);
  return currentStock;
}
async function checkStock(item) {
  const stock = await checkAndRestock(item);
  return stock > 0;
}
async function decreaseStock(item) {
  const stock = await loadStock();
  if (!stock[item.key]) stock[item.key] = { stock: 0, last: 0 };
  stock[item.key].stock = Math.max(0, (stock[item.key].stock || 0) - 1);
  await saveStock(stock);
}
async function nextRestock(item) {
  const stock = await loadStock();
  const now = Date.now();
  if (!stock[item.key]) stock[item.key] = { stock: 0, last: 0 };
  let periodMs = item.period * 60 * 60 * 1000;
  let last = stock[item.key].last || 0;
  let nextTime = last + periodMs;
  if (stock[item.key].stock >= MAX_STOCK[item.key]) return 0;
  return Math.max(0, Math.floor((nextTime - now) / 1000));
}

const userBuying = {};
const sessions = new Map();

async function cleanupSession(userId) {
  const s = sessions.get(userId);
  if (!s) return;
  try { clearInterval(s.interval); } catch {}
  try { if (s.collector && !s.collector.ended) s.collector.stop('cleanup'); } catch {}
  try { await s.interaction.deleteReply(); } catch {}
  sessions.delete(userId);
  userBuying[userId] = false;
}

function hexToImgUrl(hex) { return `https://singlecolorimage.com/get/${hex.replace('#', '')}/100x100`; }
function getRemainSec(expireAt) { return Math.max(0, Math.floor((expireAt - Date.now()) / 1000)); }
function fmtRemain(sec) {
  if (sec === null) return 'ÏòÅÍµ¨';
  if (sec <= 0) return 'ÎßåÎ£å';
  const d = Math.floor(sec / 86400);
  const h = Math.floor((sec % 86400) / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = sec % 60;
  const parts = [];
  if (d) parts.push(`${d}Ïùº`);
  if (h) parts.push(`${h}ÏãúÍ∞Ñ`);
  if (m) parts.push(`${m}Î∂Ñ`);
  if (!d && !h && !m) parts.push(`${s}Ï¥à`);
  return parts.join(' ');
}

async function loadNickColorStates() {
  const data = await loadJson(nickColorStatePath);
  return data;
}
async function saveNickColorStates(data) {
  await saveJson(nickColorStatePath, data);
}

async function ensureUserNickColorState(guild, userId) {
  const states = await loadNickColorStates();
  if (!states[userId]) {
    const ROLES = await loadJson(nicknameRolesPath);
    const roleIds = Object.values(ROLES).map(r => r.roleId);
    const member = await guild.members.fetch(userId).catch(() => null);
    const now = Date.now();
    states[userId] = { activeRoleId: null, roles: {} };
    if (member) {
      const owned = roleIds.filter(rid => member.roles.cache.has(rid));
      if (owned.length > 0) {
        for (const rid of owned) {
          states[userId].roles[rid] = { remainingSec: 7 * 24 * 3600, isPerm: false };
        }
        const active = owned[0];
        states[userId].activeRoleId = active;
        states[userId].roles[active] = { expireAt: now + 7 * 24 * 3600 * 1000, isPerm: false };
      }
    }
    await saveNickColorStates(states);
  }
  return states[userId];
}

async function reconcileExpired(guild, userId) {
  const states = await loadNickColorStates();
  const st = states[userId];
  if (!st) return;
  const now = Date.now();
  if (st.activeRoleId) {
    const rec = st.roles[st.activeRoleId];
    if (rec && !rec.isPerm && rec.expireAt && rec.expireAt <= now) {
      const member = await guild.members.fetch(userId).catch(() => null);
      if (member) {
        try { await member.roles.remove(st.activeRoleId, 'ÎãâÎÑ§ÏûÑ ÏÉâÏÉÅ Í∏∞Í∞Ñ ÎßåÎ£å'); } catch {}
      }
      const remain = 0;
      st.roles[st.activeRoleId] = { remainingSec: remain, isPerm: false };
      st.activeRoleId = null;
      await saveNickColorStates(states);
    }
  }
}

async function activateNickColor(guild, userId, roleId) {
  const states = await loadNickColorStates();
  const ROLES = await loadJson(nicknameRolesPath);
  const roleIds = Object.values(ROLES).map(r => r.roleId);
  const st = states[userId] || { activeRoleId: null, roles: {} };
  states[userId] = st;
  st.roles[roleId] = st.roles[roleId] || { remainingSec: 0, isPerm: false };
  await reconcileExpired(guild, userId);
  const now = Date.now();
  const member = await guild.members.fetch(userId);
  if (st.activeRoleId && st.activeRoleId !== roleId) {
    const prev = st.roles[st.activeRoleId];
    if (prev && !prev.isPerm) {
      const left = Math.max(0, Math.floor((prev.expireAt || now) - now) / 1000);
      st.roles[st.activeRoleId] = { remainingSec: Math.floor(left), isPerm: false };
    }
  }
  const tgt = st.roles[roleId];
  if (!tgt.isPerm) {
    if (tgt.remainingSec === undefined && tgt.expireAt) {
      const left = Math.max(0, Math.floor((tgt.expireAt - now) / 1000));
      st.roles[roleId] = { expireAt: now + left * 1000, isPerm: false };
    } else {
      const left = Math.max(0, tgt.remainingSec || 0);
      st.roles[roleId] = { expireAt: now + left * 1000, isPerm: false };
    }
  }
  st.activeRoleId = roleId;
  if (NICKNAME_ROLE_PER_USER > 0) {
    for (const rId of roleIds) {
      if (rId !== roleId && member.roles.cache.has(rId)) {
        try { await member.roles.remove(rId, 'ÏÉâÏÉÅ Ï§ëÎ≥µ Î∞©ÏßÄ'); } catch {}
      }
    }
  }
  try { await member.roles.add(roleId, 'ÎãâÎÑ§ÏûÑ ÏÉâÏÉÅ ÌôúÏÑ±Ìôî'); } catch {}
  await saveNickColorStates(states);
}

async function addNickColorTime(userId, roleId, addSeconds) {
  const states = await loadNickColorStates();
  const st = states[userId] || { activeRoleId: null, roles: {} };
  states[userId] = st;
  st.roles[roleId] = st.roles[roleId] || { remainingSec: 0, isPerm: false };
  const now = Date.now();
  if (st.activeRoleId === roleId && !st.roles[roleId].isPerm) {
    const cur = st.roles[roleId].expireAt ? Math.max(0, st.roles[roleId].expireAt - now) : 0;
    st.roles[roleId].expireAt = now + cur + addSeconds * 1000;
  } else {
    if (!st.roles[roleId].isPerm) {
      const cur = Math.max(0, st.roles[roleId].remainingSec || 0);
      st.roles[roleId].remainingSec = cur + addSeconds;
    }
  }
  await saveNickColorStates(states);
}

async function setNickColorPermanent(userId, roleId) {
  const states = await loadNickColorStates();
  const st = states[userId] || { activeRoleId: null, roles: {} };
  states[userId] = st;
  st.roles[roleId] = { isPerm: true };
  await saveNickColorStates(states);
}

async function getRoleRemainInfo(guild, userId, roleId) {
  const states = await ensureUserNickColorState(guild, userId);
  const stRec = states.roles[roleId];
  if (!stRec) return { owned: false, active: false, remainText: 'ÎØ∏Î≥¥Ïú†', remainSec: 0, isPerm: false };
  if (stRec.isPerm) return { owned: true, active: states.activeRoleId === roleId, remainText: 'ÏòÅÍµ¨', remainSec: null, isPerm: true };
  if (states.activeRoleId === roleId) {
    const sec = getRemainSec(stRec.expireAt || Date.now());
    return { owned: true, active: true, remainText: fmtRemain(sec), remainSec: sec, isPerm: false };
  } else {
    const sec = Math.max(0, stRec.remainingSec || 0);
    return { owned: true, active: false, remainText: `Ï†ïÏßÄ ${fmtRemain(sec)}`, remainSec: sec, isPerm: false };
  }
}

async function renderHome(i, expireAt) {
  const be = await loadJson(bePath);
  const cur = be[i.user.id]?.amount || 0;
  const embed = new EmbedBuilder()
    .setTitle('üõçÔ∏è ÏÉÅÏ†ê')
    .setDescription(
      `üî∑ ÎÇ¥ ÌååÎûë Ï†ïÏàò: ${numFmt(cur)} BE\n` +
      `ÏïÑÎûòÏóêÏÑú ÏõêÌïòÎäî ÏÉÅÏ†êÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.\n` +
      `ÎãâÎÑ§ÏûÑ ÏÉâÏÉÅ, Í∞úÏù∏Ï±ÑÎÑê Í≥ÑÏïΩÍ∏à, ÏõîÏÑ∏ ÎÇ©Î∂ÄÌïòÍ∏∞, ÌïúÏ†ïÌåê Ïπ≠Ìò∏, Í∞ïÌôî ÏïÑÏù¥ÌÖú, Î∞∞ÌãÄ ÏïÑÏù¥ÌÖú, Î∞∞ÌãÄ Ïä§ÌÇ¨`
    );
  const row1 = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId('nav_nickname').setLabel('üé® ÎãâÎÑ§ÏûÑ ÏÉâÏÉÅ').setStyle(ButtonStyle.Primary),
    new ButtonBuilder().setCustomId('nav_channel').setLabel('üí∏ Í∞úÏù∏Ï±ÑÎÑê Í≥ÑÏïΩÍ∏à').setStyle(ButtonStyle.Primary),
    new ButtonBuilder().setCustomId('nav_rent').setLabel('üìÑ ÏõîÏÑ∏ ÎÇ©Î∂ÄÌïòÍ∏∞').setStyle(ButtonStyle.Primary),
    new ButtonBuilder().setCustomId('nav_title').setLabel('üèÖ ÌïúÏ†ïÌåê Ïπ≠Ìò∏').setStyle(ButtonStyle.Primary)
  );
  const row2 = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId('nav_upgrade').setLabel('ü™Ñ Í∞ïÌôî ÏïÑÏù¥ÌÖú').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('nav_item').setLabel('ü•∑ Î∞∞ÌãÄ ÏïÑÏù¥ÌÖú').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('nav_skill').setLabel('üìö Î∞∞ÌãÄ Ïä§ÌÇ¨').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('shop_close').setLabel('ÏÉÅÏ†ê Îã´Í∏∞').setStyle(ButtonStyle.Danger)
  );
  return {
    content: `‚è≥ ÏÉÅÏ†ê Ïú†Ìö® ÏãúÍ∞Ñ: 3Î∂Ñ (ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${getRemainSec(expireAt)}Ï¥à)`,
    embeds: [embed],
    components: [row1, row2]
  };
}

async function renderNicknameShop(guild, userId, page, expireAt) {
  const be = await loadJson(bePath);
  const curBe = be[userId]?.amount || 0;
  const ROLES = await loadJson(nicknameRolesPath);
  const roleList = Object.values(ROLES);
  const ROLES_PER_PAGE = 1;
  const maxPage = Math.max(1, Math.ceil(roleList.length / ROLES_PER_PAGE));
  if (page < 0) page = 0;
  if (page >= maxPage) page = maxPage - 1;
  await ensureUserNickColorState(guild, userId);
  await reconcileExpired(guild, userId);
  const member = await guild.members.fetch(userId);
  const showRoles = roleList.slice(page * ROLES_PER_PAGE, (page + 1) * ROLES_PER_PAGE);
  const embed = new EmbedBuilder().setTitle('üé® ÎãâÎÑ§ÏûÑ ÏÉâÏÉÅ ÏÉÅÏ†ê (Í∏∞Í∞ÑÏ†ú/ÏòÅÍµ¨Ï†ú)').setDescription(`üî∑ ÎÇ¥ ÌååÎûë Ï†ïÏàò: ${numFmt(curBe)} BE`).setFooter({ text: `Ï¥ù ÏÉâÏÉÅ Ïó≠Ìï†: ${roleList.length} | ÌéòÏù¥ÏßÄ ${page + 1}/${maxPage}` });

  if (showRoles[0]?.color) embed.setImage(hexToImgUrl(showRoles[0].color));
  for (const role of showRoles) {
    const info = await getRoleRemainInfo(guild, userId, role.roleId);
    const activeTag = info.active ? ' | ÌôúÏÑ±ÌôîÎê®' : '';
    embed.addFields({
      name: `${role.emoji || ''} ${role.name}`,
      value:
        `${role.desc}\n` +
        `${role.color ? `\`ÏÉâÏÉÅÏΩîÎìú:\` ${role.color}\n[Ïª¨Îü¨ Î∞ïÏä§ ÎØ∏Î¶¨Î≥¥Í∏∞](${hexToImgUrl(role.color)})\n` : ''}` +
        `Î≥¥Ïú†ÏÉÅÌÉú: ${info.owned ? (info.isPerm ? 'ÏòÅÍµ¨' : info.remainText) + activeTag : 'ÎØ∏Î≥¥Ïú†'}\n` +
        `Í∏∞Í∞ÑÏ†ú Í∞ÄÍ≤©: ${DURATION_OPTIONS.map(o => `${o.label} ${numFmt(o.price)} BE`).join(' | ')}` +
        `${role.permPrice ? `\nÏòÅÍµ¨Ï†ú Í∞ÄÍ≤©: ${numFmt(role.permPrice)} BE` : ''}`,
      inline: false
    });
  }

  const rowBuy1 = new ActionRowBuilder();
  const r = showRoles[0];
  if (r) {
    for (const opt of DURATION_OPTIONS) {
      rowBuy1.addComponents(
        new ButtonBuilder()
          .setCustomId(`nickname_buy_${r.roleId}_${opt.key}`)
          .setLabel(`${opt.label} Íµ¨Îß§`)
          .setStyle(ButtonStyle.Primary)
      );
    }
  }
  const rowBuy2 = new ActionRowBuilder();
  if (r) {
    const hasPerm = !!r.permPrice;
    rowBuy2.addComponents(
      new ButtonBuilder().setCustomId(`nickname_activate_${r.roleId}`).setLabel('Ïù¥ ÏÉâÏÉÅ ÌôúÏÑ±Ìôî').setStyle(ButtonStyle.Success),
      new ButtonBuilder().setCustomId('nick_my').setLabel('ÎÇ¥ Î≥¥Ïú† ÌòÑÌô©').setStyle(ButtonStyle.Secondary),
      new ButtonBuilder().setCustomId('nav_home').setLabel('Ìôà').setStyle(ButtonStyle.Secondary),
      new ButtonBuilder().setCustomId('shop_close').setLabel('ÏÉÅÏ†ê Îã´Í∏∞').setStyle(ButtonStyle.Danger)
    );
    if (hasPerm) {
      rowBuy2.components.unshift(
        new ButtonBuilder().setCustomId(`nickname_buy_${r.roleId}_perm`).setLabel('ÏòÅÍµ¨Ï†ú Íµ¨Îß§').setStyle(ButtonStyle.Primary)
      );
    }
  }
  const rowPage = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId('nick_prev').setLabel('Ïù¥Ï†Ñ').setStyle(ButtonStyle.Secondary).setDisabled(page === 0),
    new ButtonBuilder().setCustomId('nick_next').setLabel('Îã§Ïùå').setStyle(ButtonStyle.Secondary).setDisabled(page + 1 >= maxPage)
  );

  return {
    content: `‚è≥ ÏÉÅÏ†ê Ïú†Ìö® ÏãúÍ∞Ñ: 3Î∂Ñ (ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${getRemainSec(expireAt)}Ï¥à)`,
    embeds: [embed],
    components: [rowBuy1, rowBuy2, rowPage],
    page
  };
}

async function renderMyNickStatus(guild, userId, expireAt) {
  const ROLES = await loadJson(nicknameRolesPath);
  const states = await ensureUserNickColorState(guild, userId);
  await reconcileExpired(guild, userId);
  const embed = new EmbedBuilder().setTitle('üé® ÎÇ¥ ÎãâÎÑ§ÏûÑ ÏÉâÏÉÅ ÌòÑÌô©');
  const entries = Object.values(ROLES)
    .filter(r => states.roles[r.roleId])
    .map(r => ({ r, info: states.roles[r.roleId] }));
  if (entries.length === 0) {
    embed.setDescription('Î≥¥Ïú†Ìïú ÎãâÎÑ§ÏûÑ ÏÉâÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§.');
  } else {
    for (const { r, info } of entries) {
      const isActive = states.activeRoleId === r.roleId;
      const isPerm = !!info.isPerm;
      let remainTxt = 'ÎØ∏Î≥¥Ïú†';
      if (isPerm) remainTxt = 'ÏòÅÍµ¨';
      else if (isActive) remainTxt = fmtRemain(getRemainSec(info.expireAt || Date.now()));
      else remainTxt = `Ï†ïÏßÄ ${fmtRemain(Math.max(0, info.remainingSec || 0))}`;
      embed.addFields({ name: `${r.emoji || ''} ${r.name}${isActive ? ' (ÌôúÏÑ±Ìôî)' : ''}`, value: remainTxt, inline: false });
    }
  }
  const row = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId('nav_nickname').setLabel('ÏÉâÏÉÅ ÏÉÅÏ†êÏúºÎ°ú').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('nav_home').setLabel('Ìôà').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('shop_close').setLabel('ÏÉÅÏ†ê Îã´Í∏∞').setStyle(ButtonStyle.Danger)
  );
  return {
    content: `‚è≥ ÏÉÅÏ†ê Ïú†Ìö® ÏãúÍ∞Ñ: 3Î∂Ñ (ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${getRemainSec(expireAt)}Ï¥à)`,
    embeds: [embed],
    components: [row]
  };
}

async function renderChannelShop(guild, userId, expireAt) {
  const member = await guild.members.fetch(userId);
  let already = member.roles.cache.has(CHANNEL_ROLE_ID);
  const embed = new EmbedBuilder()
    .setTitle('üõéÔ∏è Í∞úÏù∏Ï±ÑÎÑê Í≥ÑÏïΩÍ∏à')
    .setDescription(`3,000,000 BE\nÏó≠Ìï† Íµ¨Îß§Ïãú Í∞úÏù∏ Ï†ÑÏö© Ï±ÑÎÑêÏùÑ Ïã†Ï≤≠Ìï† Ïàò ÏûàÎäî Í∂åÌïúÏù¥ Î∂ÄÏó¨Îê©ÎãàÎã§.\n\n${already ? '> Ïù¥ÎØ∏ Î≥¥Ïú† Ï§ë!' : '> Ï¶âÏãú Íµ¨Îß§ Í∞ÄÎä•'}`)
    .setColor('#FFD700');
  const row = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId('channel_buy').setLabel(already ? 'Ïù¥ÎØ∏ Î≥¥Ïú†Ï§ë' : 'Íµ¨Îß§').setStyle(already ? ButtonStyle.Secondary : ButtonStyle.Primary).setDisabled(already),
    new ButtonBuilder().setCustomId('nav_home').setLabel('Ìôà').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('shop_close').setLabel('ÏÉÅÏ†ê Îã´Í∏∞').setStyle(ButtonStyle.Danger)
  );
  return {
    content: `‚è≥ ÏÉÅÏ†ê Ïú†Ìö® ÏãúÍ∞Ñ: 3Î∂Ñ (ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${getRemainSec(expireAt)}Ï¥à)`,
    embeds: [embed],
    components: [row]
  };
}

async function renderRent(guild, userId, expireAt) {
  const be = await loadJson(bePath);
  const curBe = be[userId]?.amount || 0;
  const member = await guild.members.fetch(userId);
  const owned = member.roles.cache.has(RENT_ROLE_ID);
  const embed = new EmbedBuilder()
    .setTitle('üìÑ ÏõîÏÑ∏ ÎÇ©Î∂ÄÌïòÍ∏∞')
    .setDescription(
      `ÎÇ©Î∂Ä Í∏àÏï°: ${numFmt(RENT_PRICE)} BE\nÏó≠Ìï† ÏßÄÍ∏â: ÏõîÏÑ∏ ÎÇ©Î∂Ä Ï¶ùÎ™ÖÏÑú\nÌòÑÏû¨ Î≥¥Ïú† BE: ${numFmt(curBe)} BE\n${owned ? '> Ïù¥ÎØ∏ Ïù¥Î≤àÎã¨ ÏõîÏÑ∏Î•º ÎÇ©Î∂ÄÌñàÏäµÎãàÎã§.' : '> ‚ö†Ô∏è Í∞úÏù∏ ÏùåÏÑ±Ï±ÑÎÑêÏùÑ ÏÜåÏßÄÌïú Í≤ΩÏö∞ÏóêÎßå Íµ¨Îß§ÌïòÏÑ∏Ïöî.'}`
    );
  const row = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId('rent_pay').setLabel(owned ? 'Ïù¥ÎØ∏ Î≥¥Ïú†Ï§ë' : 'ÏõîÏÑ∏ ÎÇ©Î∂Ä').setStyle(owned ? ButtonStyle.Secondary : ButtonStyle.Primary).setDisabled(owned),
    new ButtonBuilder().setCustomId('nav_home').setLabel('Ìôà').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('shop_close').setLabel('ÏÉÅÏ†ê Îã´Í∏∞').setStyle(ButtonStyle.Danger)
  );
  return {
    content: `‚è≥ ÏÉÅÏ†ê Ïú†Ìö® ÏãúÍ∞Ñ: 3Î∂Ñ (ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${getRemainSec(expireAt)}Ï¥à)`,
    embeds: [embed],
    components: [row]
  };
}

async function renderTitleShop(guild, userId, page, expireAt) {
  const be = await loadJson(bePath);
  const curBe = be[userId]?.amount || 0;
  const TITLES = await loadJson(titlesPath);
  const titleList = Object.values(TITLES);
  const TITLE_PER_PAGE = 1;
  const maxPage = Math.max(1, Math.ceil(titleList.length / TITLE_PER_PAGE));
  if (page < 0) page = 0;
  if (page >= maxPage) page = maxPage - 1;
  const member = await guild.members.fetch(userId);
  const showTitles = titleList.slice(page * TITLE_PER_PAGE, (page + 1) * TITLE_PER_PAGE);
  const embed = new EmbedBuilder()
    .setTitle('üèÖ ÌïúÏ†ïÌåê Ïπ≠Ìò∏ ÏÉÅÏ†ê')
    .setDescription(
      `üî∑ ÎÇ¥ ÌååÎûë Ï†ïÏàò: ${numFmt(curBe)} BE\n` +
      showTitles.map((t, i) => {
        let owned = member.roles.cache.has(t.roleId);
        let stockMsg = (t.stock === undefined || t.stock === null) ? '' : (t.stock <= 0 ? '\n> [ÌíàÏ†à]' : `\n> [ÎÇ®ÏùÄ ÏàòÎüâ: ${t.stock}Í∞ú]`);
        return `#${i+1+page*TITLE_PER_PAGE} | ${t.emoji||''} **${t.name}** (${numFmt(t.price)} BE)\n${t.desc}\n${stockMsg}\n> ${owned ? '**[Î≥¥Ïú†Ï§ë]**' : ''}`;
      }).join('\n\n')
    )
    .setFooter({ text: `Ï¥ù Ïπ≠Ìò∏: ${titleList.length} | ÌéòÏù¥ÏßÄ ${page + 1}/${maxPage}` });
  if (showTitles[0]?.color && typeof showTitles[0].color === 'string') {
    if (showTitles[0].color.startsWith('http')) embed.setImage(showTitles[0].color);
    else if (/^#?[0-9a-fA-F]{6}$/.test(showTitles[0].color.replace('#',''))) embed.setColor(showTitles[0].color);
  }
  const row = new ActionRowBuilder();
  showTitles.forEach(t => {
    let owned = member.roles.cache.has(t.roleId);
    row.addComponents(
      new ButtonBuilder()
        .setCustomId(`title_buy_${t.roleId}`)
        .setLabel(owned ? `${t.name} Î≥¥Ïú†Ï§ë` : `${t.name} Íµ¨Îß§`)
        .setStyle(owned || (t.stock!==undefined&&t.stock<=0) ? ButtonStyle.Secondary : ButtonStyle.Primary)
        .setDisabled(owned || (t.stock!==undefined&&t.stock<=0))
    );
  });
  const rowPage = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId('nav_home').setLabel('Ìôà').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('title_prev').setLabel('Ïù¥Ï†Ñ').setStyle(ButtonStyle.Secondary).setDisabled(page === 0),
    new ButtonBuilder().setCustomId('title_refresh').setLabel('ÏÉàÎ°úÍ≥†Ïπ®').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('title_next').setLabel('Îã§Ïùå').setStyle(ButtonStyle.Secondary).setDisabled(page + 1 >= maxPage),
    new ButtonBuilder().setCustomId('shop_close').setLabel('ÏÉÅÏ†ê Îã´Í∏∞').setStyle(ButtonStyle.Danger)
  );
  return {
    content: `‚è≥ ÏÉÅÏ†ê Ïú†Ìö® ÏãúÍ∞Ñ: 3Î∂Ñ (ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${getRemainSec(expireAt)}Ï¥à)`,
    embeds: [embed],
    components: [row, rowPage],
    page
  };
}

async function renderUpgradeShop(userId, expireAt) {
  const be = await loadJson(bePath);
  const curBe = be[userId]?.amount || 0;
  const stocks = {};
  for (const item of Í∞ïÌôîITEMS) {
    stocks[item.key] = await checkAndRestock(item);
  }
  const embed = new EmbedBuilder()
    .setTitle("ü™Ñ Í∞ïÌôî ÏïÑÏù¥ÌÖú ÏÉÅÏ†ê (Ïó≠Ìï† ÏÉÅÌíà)")
    .setDescription(
      `üî∑ ÎÇ¥ ÌååÎûë Ï†ïÏàò: ${numFmt(curBe)} BE\n` +
      await Promise.all(Í∞ïÌôîITEMS.map(async (item, i) => {
        const stock = stocks[item.key];
        let msg = '';
        if (stock <= 0) {
          const left = await nextRestock(item);
          if (left > 0) {
            const h = Math.floor(left / 3600);
            const m = Math.floor((left % 3600) / 60);
            const s = left % 60;
            msg = `\n> **[ÌíàÏ†à]** Ï∂©Ï†ÑÍπåÏßÄ ${h ? `${h}ÏãúÍ∞Ñ ` : ''}${m ? `${m}Î∂Ñ ` : ''}${s}Ï¥à ÎÇ®Ïùå`;
          } else {
            msg = `\n> **[ÌíàÏ†à]**`;
          }
        } else {
          msg = `\n> **[ÎÇ®ÏùÄ Ïû¨Í≥†: ${stock}Í∞ú]**`;
        }
        return `#${i + 1} | ${item.emoji} **${item.name}** (${numFmt(item.price)} BE)\n${item.desc}${msg}\n`
      })).then(lines => lines.join("\n"))
    )
    .setFooter({ text: `Í≥†Ïú†ÏÉÅÌíà: 1ÌöåÏÑ± Ïó≠Ìï† ÏïÑÏù¥ÌÖú | Íµ¨Îß§Ïãú Ï¶âÏãú ÏßÄÍ∏â` });
  const rowBuy = new ActionRowBuilder();
  Í∞ïÌôîITEMS.forEach(item => {
    const stock = stocks[item.key];
    rowBuy.addComponents(
      new ButtonBuilder()
        .setCustomId(`upgrade_buy_${item.roleId}`)
        .setLabel(stock > 0 ? `${item.name} Íµ¨Îß§` : `${item.name} ÌíàÏ†à`)
        .setStyle(stock > 0 ? ButtonStyle.Primary : ButtonStyle.Secondary)
        .setDisabled(stock <= 0)
    );
  });
  const rowNav = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId('nav_home').setLabel('Ìôà').setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId('shop_close').setLabel('ÏÉÅÏ†ê Îã´Í∏∞').setStyle(ButtonStyle.Danger)
  );
  return {
    content: `‚è≥ ÏÉÅÏ†ê Ïú†Ìö® ÏãúÍ∞Ñ: 3Î∂Ñ (ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${getRemainSec(expireAt)}Ï¥à)`,
    embeds: [embed],
    components: [rowBuy, rowNav]
  };
}

async function renderItemShop(userId, page, expireAt) {
  const be = await loadJson(bePath);
  const curBe = be[userId]?.amount || 0;
  const ITEMS = require('../utils/items.js');
  const ITEM_LIST = Object.values(ITEMS);
  const sorted = ITEM_LIST.slice().sort((a, b) => b.price - a.price);
  const ITEMS_PER_PAGE = 5;
  const maxPage = Math.max(1, Math.ceil(ITEM_LIST.length / ITEMS_PER_PAGE));
  if (page < 0) page = 0;
  if (page >= maxPage) page = maxPage - 1;
  const showItems = sorted.slice(page * ITEMS_PER_PAGE, (page + 1) * ITEMS_PER_PAGE);
  const embed = new EmbedBuilder()
    .setTitle("üõí ÏïÑÏù¥ÌÖú ÏÉÅÏ†ê")
    .setDescription(
      `üî∑ ÎÇ¥ ÌååÎûë Ï†ïÏàò: ${numFmt(curBe)} BE\n` +
      showItems.map((item, i) =>
        `#${i + 1 + page * ITEMS_PER_PAGE} | ${item.icon || ""} **${item.name}** (${numFmt(item.price)} BE)\n${item.desc}`
      ).join("\n\n"))
    .setFooter({ text: `Ï¥ù ÏïÑÏù¥ÌÖú: ${ITEM_LIST.length} | ÌéòÏù¥ÏßÄ ${page + 1}/${maxPage}` });
  const row1 = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId("item_prev").setLabel("Ïù¥Ï†Ñ ÌéòÏù¥ÏßÄ").setStyle(ButtonStyle.Secondary).setDisabled(page === 0),
    new ButtonBuilder().setCustomId("item_refresh").setLabel("ÏÉàÎ°úÍ≥†Ïπ®").setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId("item_next").setLabel("Îã§Ïùå ÌéòÏù¥ÏßÄ").setStyle(ButtonStyle.Secondary).setDisabled(page + 1 >= maxPage),
    new ButtonBuilder().setCustomId("nav_home").setLabel("Ìôà").setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId("shop_close").setLabel("ÏÉÅÏ†ê Îã´Í∏∞").setStyle(ButtonStyle.Danger)
  );
  const rowBuy = new ActionRowBuilder();
  showItems.forEach(item => {
    rowBuy.addComponents(
      new ButtonBuilder()
        .setCustomId(`item_buy_${item.name}`)
        .setLabel(`${item.name} Íµ¨Îß§`)
        .setStyle(ButtonStyle.Primary)
    );
  });
  return {
    content: `‚è≥ ÏÉÅÏ†ê Ïú†Ìö® ÏãúÍ∞Ñ: 3Î∂Ñ (ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${getRemainSec(expireAt)}Ï¥à)`,
    embeds: [embed],
    components: [row1, rowBuy],
    page
  };
}

async function renderSkillShop(userId, page, expireAt) {
  const be = await loadJson(bePath);
  const curBe = be[userId]?.amount || 0;
  const SKILLS = require('../utils/active-skills.js');
  const SKILL_LIST = Object.values(SKILLS);
  const sorted = SKILL_LIST.slice().sort((a, b) => b.price - a.price);
  const SKILLS_PER_PAGE = 5;
  const maxPage = Math.max(1, Math.ceil(SKILL_LIST.length / SKILLS_PER_PAGE));
  if (page < 0) page = 0;
  if (page >= maxPage) page = maxPage - 1;
  const showSkills = sorted.slice(page * SKILLS_PER_PAGE, (page + 1) * SKILLS_PER_PAGE);
  const embed = new EmbedBuilder()
    .setTitle("üìö Ïä§ÌÇ¨ ÏÉÅÏ†ê")
    .setDescription(
      `üî∑ ÎÇ¥ ÌååÎûë Ï†ïÏàò: ${numFmt(curBe)} BE\n` +
      showSkills.map((skill, i) =>
        `#${i + 1 + page * SKILLS_PER_PAGE} | ${skill.icon || ""} **${skill.name}** (${numFmt(skill.price)} BE)\n${skill.desc}`
      ).join("\n\n"))
    .setFooter({ text: `Ï¥ù Ïä§ÌÇ¨: ${SKILL_LIST.length} | ÌéòÏù¥ÏßÄ ${page + 1}/${maxPage}` });
  const row1 = new ActionRowBuilder().addComponents(
    new ButtonBuilder().setCustomId("skill_prev").setLabel("Ïù¥Ï†Ñ ÌéòÏù¥ÏßÄ").setStyle(ButtonStyle.Secondary).setDisabled(page === 0),
    new ButtonBuilder().setCustomId("skill_refresh").setLabel("ÏÉàÎ°úÍ≥†Ïπ®").setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId("skill_next").setLabel("Îã§Ïùå ÌéòÏù¥ÏßÄ").setStyle(ButtonStyle.Secondary).setDisabled(page + 1 >= maxPage),
    new ButtonBuilder().setCustomId("nav_home").setLabel("Ìôà").setStyle(ButtonStyle.Secondary),
    new ButtonBuilder().setCustomId("shop_close").setLabel("ÏÉÅÏ†ê Îã´Í∏∞").setStyle(ButtonStyle.Danger)
  );
  const rowBuy = new ActionRowBuilder();
  showSkills.forEach(skill => {
    rowBuy.addComponents(
      new ButtonBuilder()
        .setCustomId(`skill_buy_${skill.name}`)
        .setLabel(`${skill.name} Íµ¨Îß§`)
        .setStyle(ButtonStyle.Primary)
    );
  });
  return {
    content: `‚è≥ ÏÉÅÏ†ê Ïú†Ìö® ÏãúÍ∞Ñ: 3Î∂Ñ (ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${getRemainSec(expireAt)}Ï¥à)`,
    embeds: [embed],
    components: [row1, rowBuy],
    page
  };
}

module.exports = {
  data: new SlashCommandBuilder()
    .setName('ÏÉÅÏ†ê')
    .setDescription('ÌååÎûë Ï†ïÏàò(BE)Î°ú Îã§ÏñëÌïú ÏïÑÏù¥ÌÖú/Í∞ïÌôî/Ïó≠Ìï†ÏùÑ Íµ¨Îß§Ìï† Ïàò ÏûàÏäµÎãàÎã§.'),
  async execute(interaction) {
    try {
      if (sessions.has(interaction.user.id)) {
        const prev = sessions.get(interaction.user.id);
        try { if (prev.collector && !prev.collector.ended) prev.collector.stop('replaced'); } catch {}
        await cleanupSession(interaction.user.id);
      }
      const expireSec = 180;
      const sessionExpireAt = Date.now() + expireSec * 1000;
      let state = { view: 'home', page: 0 };
      await interaction.deferReply({ ephemeral: true });

      await ensureUserNickColorState(interaction.guild, interaction.user.id);
      await reconcileExpired(interaction.guild, interaction.user.id);

      const home = await renderHome(interaction, sessionExpireAt);
      const shopMsg = await interaction.editReply(home);

      const interval = setInterval(async () => {
        try {
          await reconcileExpired(interaction.guild, interaction.user.id);
          let payload;
          if (state.view === 'home') payload = await renderHome(interaction, sessionExpireAt);
          if (state.view === 'nickname') payload = await renderNicknameShop(interaction.guild, interaction.user.id, state.page, sessionExpireAt);
          if (state.view === 'channel') payload = await renderChannelShop(interaction.guild, interaction.user.id, sessionExpireAt);
          if (state.view === 'rent') payload = await renderRent(interaction.guild, interaction.user.id, sessionExpireAt);
          if (state.view === 'title') payload = await renderTitleShop(interaction.guild, interaction.user.id, state.page, sessionExpireAt);
          if (state.view === 'upgrade') payload = await renderUpgradeShop(interaction.user.id, sessionExpireAt);
          if (state.view === 'item') payload = await renderItemShop(interaction.user.id, state.page, sessionExpireAt);
          if (state.view === 'skill') payload = await renderSkillShop(interaction.user.id, state.page, sessionExpireAt);
          await interaction.editReply(payload);
        } catch {}
      }, 1000);

      const collector = interaction.channel.createMessageComponentCollector({
        filter: i => i.user.id === interaction.user.id && i.message.id === shopMsg.id,
        time: expireSec * 1000
      });

      sessions.set(interaction.user.id, { interaction, collector, interval });

      collector.on('collect', async i => {
        try { await reconcileExpired(interaction.guild, i.user.id); } catch {}
        if (i.customId === 'shop_close') {
          collector.stop('user');
          try { await i.update({ content: 'ÏÉÅÏ†êÏù¥ Îã´ÌòîÏäµÎãàÎã§.', embeds: [], components: [] }); } catch {}
          return;
        }
        if (i.customId === 'nav_home') {
          state.view = 'home'; state.page = 0;
          const payload = await renderHome(interaction, sessionExpireAt);
          await i.update(payload);
          return;
        }
        if (i.customId === 'nav_nickname') {
          state.view = 'nickname'; state.page = 0;
          const payload = await renderNicknameShop(interaction.guild, interaction.user.id, state.page, sessionExpireAt);
          await i.update(payload);
          return;
        }
        if (i.customId === 'nav_channel') {
          state.view = 'channel'; state.page = 0;
          const payload = await renderChannelShop(interaction.guild, interaction.user.id, sessionExpireAt);
          await i.update(payload);
          return;
        }
        if (i.customId === 'nav_rent') {
          state.view = 'rent'; state.page = 0;
          const payload = await renderRent(interaction.guild, interaction.user.id, sessionExpireAt);
          await i.update(payload);
          return;
        }
        if (i.customId === 'nav_title') {
          state.view = 'title'; state.page = 0;
          const payload = await renderTitleShop(interaction.guild, interaction.user.id, state.page, sessionExpireAt);
          await i.update(payload);
          return;
        }
        if (i.customId === 'nav_upgrade') {
          state.view = 'upgrade'; state.page = 0;
          const payload = await renderUpgradeShop(interaction.user.id, sessionExpireAt);
          await i.update(payload);
          return;
        }
        if (i.customId === 'nav_item') {
          state.view = 'item'; state.page = 0;
          const payload = await renderItemShop(interaction.user.id, state.page, sessionExpireAt);
          await i.update(payload);
          return;
        }
        if (i.customId === 'nav_skill') {
          state.view = 'skill'; state.page = 0;
          const payload = await renderSkillShop(interaction.user.id, state.page, sessionExpireAt);
          await i.update(payload);
          return;
        }

        if (state.view === 'nickname') {
          if (i.customId === 'nick_prev') {
            state.page = Math.max(0, state.page - 1);
            const payload = await renderNicknameShop(interaction.guild, interaction.user.id, state.page, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId === 'nick_next') {
            state.page = state.page + 1;
            const payload = await renderNicknameShop(interaction.guild, interaction.user.id, state.page, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId === 'nick_my') {
            const payload = await renderMyNickStatus(interaction.guild, interaction.user.id, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId.startsWith('nickname_activate_')) {
            const roleId = i.customId.replace('nickname_activate_', '');
            const states = await loadNickColorStates();
            const st = states[i.user.id] || {};
            if (!st.roles || !st.roles[roleId]) { await i.reply({ content: 'Ìï¥Îãπ ÏÉâÏÉÅÏùÑ Î≥¥Ïú†ÌïòÍ≥† ÏûàÏßÄ ÏïäÏäµÎãàÎã§.', ephemeral: true }); return; }
            try {
              await activateNickColor(i.guild, i.user.id, roleId);
              await i.reply({ content: 'ÏÑ†ÌÉùÌïú ÎãâÎÑ§ÏûÑ ÏÉâÏÉÅÏù¥ ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§.', ephemeral: true });
            } catch (e) {
              await i.reply({ content: `Ïò§Î•ò: ${e.message}`, ephemeral: true });
            }
            return;
          }
          if (i.customId.startsWith('nickname_buy_')) {
            const parts = i.customId.split('_');
            const roleId = parts[2];
            const plan = parts[3];
            const ROLES = await loadJson(nicknameRolesPath);
            const roleList = Object.values(ROLES);
            const roleData = roleList.find(x => x.roleId === roleId);
            const member = await i.guild.members.fetch(i.user.id);
            if (!roleData) { await i.reply({ content: "Ìï¥Îãπ Ïó≠Ìï†ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", ephemeral: true }); return; }
            if (userBuying[i.user.id]) { await i.reply({ content: 'Ïù¥ÎØ∏ Íµ¨Îß§ Ï≤òÎ¶¨ Ï§ëÏûÖÎãàÎã§.', ephemeral: true }); return; }
            userBuying[i.user.id] = true;
            try {
              const be = await loadJson(bePath);
              const userBeNow = be[i.user.id]?.amount || 0;
              let cost = 0;
              let isPerm = false;
              if (plan === 'perm') {
                if (!roleData.permPrice) { await i.reply({ content: 'ÏòÅÍµ¨Ï†ú Í∞ÄÍ≤©Ïù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌïòÏÑ∏Ïöî.', ephemeral: true }); return; }
                cost = roleData.permPrice;
                isPerm = true;
              } else {
                const opt = DURATION_OPTIONS.find(o => o.key === plan);
                if (!opt) { await i.reply({ content: 'ÏûòÎ™ªÎêú ÌîåÎûúÏûÖÎãàÎã§.', ephemeral: true }); return; }
                cost = opt.price;
              }
              if (userBeNow < cost) { await i.reply({ content: `ÌååÎûë Ï†ïÏàò Î∂ÄÏ°±! (Î≥¥Ïú†: ${numFmt(userBeNow)} BE)`, ephemeral: true }); return; }

              be[i.user.id] = be[i.user.id] || { amount: 0, history: [] };
              const beBackup = JSON.stringify(be);
              be[i.user.id].amount -= cost;
              be[i.user.id].history.push({ type: "spend", amount: cost, reason: `${roleData.name} ÎãâÎÑ§ÏûÑ ÏÉâÏÉÅ ${isPerm ? 'ÏòÅÍµ¨Ï†ú' : 'Í∏∞Í∞ÑÏ†ú'} Íµ¨Îß§`, timestamp: Date.now() });
              await saveJson(bePath, be);

              const states = await loadNickColorStates();
              states[i.user.id] = states[i.user.id] || { activeRoleId: null, roles: {} };
              states[i.user.id].roles[roleId] = states[i.user.id].roles[roleId] || { remainingSec: 0, isPerm: false };

              if (isPerm) {
                await setNickColorPermanent(i.user.id, roleId);
              } else {
                const opt = DURATION_OPTIONS.find(o => o.key === plan);
                await addNickColorTime(i.user.id, roleId, opt.seconds);
              }

              if (!member.roles.cache.has(roleId) && (states[i.user.id].activeRoleId === roleId || states[i.user.id].activeRoleId === null)) {
                try { await activateNickColor(i.guild, i.user.id, roleId); } catch {}
              }

              await i.reply({ content: `‚úÖ [${roleData.name}] ${isPerm ? 'ÏòÅÍµ¨Ï†ú' : 'Í∏∞Í∞ÑÏ†ú'} Íµ¨Îß§ ÏôÑÎ£å!`, ephemeral: true });
            } catch (e) {
              await i.reply({ content: `‚ùå Ïò§Î•ò: ${e.message}`, ephemeral: true });
            } finally { userBuying[i.user.id] = false; }
            return;
          }
        }

        if (state.view === 'channel') {
          if (i.customId === 'channel_buy') {
            if (userBuying[i.user.id]) { await i.reply({ content: 'Ïù¥ÎØ∏ Íµ¨Îß§ Ï≤òÎ¶¨ Ï§ëÏûÖÎãàÎã§.', ephemeral: true }); return; }
            userBuying[i.user.id] = true;
            try {
              const member = await i.guild.members.fetch(i.user.id);
              const be = await loadJson(bePath);
              const userBeNow = be[i.user.id]?.amount || 0;
              if (member.roles.cache.has(CHANNEL_ROLE_ID)) { await i.reply({ content: `Ïù¥ÎØ∏ Î≥¥Ïú† Ï§ëÏûÖÎãàÎã§.`, ephemeral: true }); return; }
              if (userBeNow < CHANNEL_ROLE_PRICE) { await i.reply({ content: `ÌååÎûë Ï†ïÏàò Î∂ÄÏ°±! (Î≥¥Ïú†: ${numFmt(userBeNow)} BE)`, ephemeral: true }); return; }
              await member.roles.add(CHANNEL_ROLE_ID, 'Í∞úÏù∏Ï±ÑÎÑê Í≥ÑÏïΩÍ∏à Íµ¨Îß§');
              be[i.user.id] = be[i.user.id] || { amount: 0, history: [] };
              be[i.user.id].amount -= CHANNEL_ROLE_PRICE;
              be[i.user.id].history.push({ type: "spend", amount: CHANNEL_ROLE_PRICE, reason: "Í∞úÏù∏Ï±ÑÎÑê Í≥ÑÏïΩÍ∏à Íµ¨Îß§", timestamp: Date.now() });
              await saveJson(bePath, be);
              await i.reply({ content: `‚úÖ Í∞úÏù∏Ï±ÑÎÑê Í≥ÑÏïΩÍ∏à Ïó≠Ìï† ÏßÄÍ∏â ÏôÑÎ£å!`, ephemeral: true });
            } catch (e) {
              await i.reply({ content: `‚ùå Ïò§Î•ò: ${e.message}`, ephemeral: true });
            } finally { userBuying[i.user.id] = false; }
            return;
          }
        }

        if (state.view === 'rent') {
          if (i.customId === 'rent_pay') {
            if (userBuying[i.user.id]) { await i.reply({ content: 'Ïù¥ÎØ∏ ÎÇ©Î∂Ä Ï≤òÎ¶¨ Ï§ëÏûÖÎãàÎã§.', ephemeral: true }); return; }
            userBuying[i.user.id] = true;
            try {
              const member = await i.guild.members.fetch(i.user.id);
              if (member.roles.cache.has(RENT_ROLE_ID)) { await i.reply({ content: `Ïù¥ÎØ∏ Ïó≠Ìï†ÏùÑ Î≥¥Ïú† Ï§ëÏûÖÎãàÎã§.`, ephemeral: true }); return; }
              const be = await loadJson(bePath);
              const userBeNow = be[i.user.id]?.amount || 0;
              if (userBeNow < RENT_PRICE) { await i.reply({ content: `ÌååÎûë Ï†ïÏàò Î∂ÄÏ°±! (Î≥¥Ïú†: ${numFmt(userBeNow)} BE)`, ephemeral: true }); return; }
              const beBackup = JSON.stringify(be);
              be[i.user.id] = be[i.user.id] || { amount: 0, history: [] };
              be[i.user.id].amount -= RENT_PRICE;
              be[i.user.id].history.push({ type: "spend", amount: RENT_PRICE, reason: "ÏõîÏÑ∏ ÎÇ©Î∂ÄÌïòÍ∏∞", timestamp: Date.now() });
              await saveJson(bePath, be);
              try {
                await member.roles.add(RENT_ROLE_ID, 'ÏõîÏÑ∏ ÎÇ©Î∂Ä Ï¶ùÎ™ÖÏÑú ÏßÄÍ∏â');
              } catch {
                await saveJson(bePath, JSON.parse(beBackup));
                await i.reply({ content: `‚ùå Ïó≠Ìï† ÏßÄÍ∏â Ïã§Ìå®! (Í∂åÌïú Î∂ÄÏ°± ÎòêÎäî ÏÑ§Ï†ï Ïò§Î•ò / BE Ï∞®Í∞ê Ï∑®ÏÜåÎê®)`, ephemeral: true });
                return;
              }
              await i.reply({ content: `‚úÖ ÏõîÏÑ∏ ÎÇ©Î∂Ä ÏôÑÎ£å! ${numFmt(RENT_PRICE)} BE Ï∞®Í∞ê, Ïó≠Ìï† ÏßÄÍ∏âÎê®.`, ephemeral: true });
            } catch (e) {
              await i.reply({ content: `‚ùå Ïò§Î•ò: ${e.message}`, ephemeral: true });
            } finally { userBuying[i.user.id] = false; }
            return;
          }
        }

        if (state.view === 'title') {
          if (i.customId === 'title_prev') {
            state.page = Math.max(0, state.page - 1);
            const payload = await renderTitleShop(interaction.guild, interaction.user.id, state.page, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId === 'title_next') {
            state.page = state.page + 1;
            const payload = await renderTitleShop(interaction.guild, interaction.user.id, state.page, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId === 'title_refresh') {
            const payload = await renderTitleShop(interaction.guild, interaction.user.id, state.page, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId.startsWith('title_buy_')) {
            const roleId = i.customId.replace('title_buy_', '');
            const TITLES = await loadJson(titlesPath);
            const titleList = Object.values(TITLES);
            const titleData = titleList.find(x => x.roleId === roleId);
            const member = await i.guild.members.fetch(i.user.id);
            if (!titleData) { await i.reply({ content: "Ìï¥Îãπ Ïπ≠Ìò∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", ephemeral: true }); return; }
            if (member.roles.cache.has(roleId)) { await i.reply({ content: `Ïù¥ÎØ∏ [${titleData.name}] Ïπ≠Ìò∏Î•º Î≥¥Ïú† Ï§ëÏûÖÎãàÎã§!`, ephemeral: true }); return; }
            if (titleData.stock !== undefined && titleData.stock !== null && titleData.stock <= 0) { await i.reply({ content: "ÌíàÏ†àÏûÖÎãàÎã§!", ephemeral: true }); return; }
            if (userBuying[i.user.id]) { await i.reply({ content: 'Ïù¥ÎØ∏ Íµ¨Îß§ Ï≤òÎ¶¨ Ï§ëÏûÖÎãàÎã§.', ephemeral: true }); return; }
            userBuying[i.user.id] = true;
            try {
              const be = await loadJson(bePath);
              const userBeNow = be[i.user.id]?.amount || 0;
              if (userBeNow < titleData.price) { await i.reply({ content: `ÌååÎûë Ï†ïÏàò Î∂ÄÏ°±! (Î≥¥Ïú†: ${numFmt(userBeNow)} BE)`, ephemeral: true }); return; }
              await member.roles.add(roleId, 'ÌïúÏ†ïÌåê Ïπ≠Ìò∏ Íµ¨Îß§');
              be[i.user.id] = be[i.user.id] || { amount: 0, history: [] };
              be[i.user.id].amount -= titleData.price;
              be[i.user.id].history.push({ type: "spend", amount: titleData.price, reason: `${titleData.name} Ïπ≠Ìò∏ Íµ¨Îß§`, timestamp: Date.now() });
              await saveJson(bePath, be);
              if (titleData.stock !== undefined && titleData.stock !== null) {
                titleData.stock--;
                const TITLES2 = await loadJson(titlesPath);
                if (TITLES2[roleId]) {
                  TITLES2[roleId].stock = titleData.stock;
                  await saveJson(titlesPath, TITLES2);
                }
              }
              await i.reply({ content: `‚úÖ [${titleData.name}] Ïπ≠Ìò∏ Ïó≠Ìï†ÏùÑ ${numFmt(titleData.price)} BEÏóê Íµ¨Îß§ ÏôÑÎ£å!`, ephemeral: true });
            } catch (e) {
              await i.reply({ content: `‚ùå Ïò§Î•ò: ${e.message}`, ephemeral: true });
            } finally { userBuying[i.user.id] = false; }
            return;
          }
        }

        if (state.view === 'upgrade') {
          const btnItem = Í∞ïÌôîITEMS.find(x => i.customId === `upgrade_buy_${x.roleId}`);
          if (btnItem) {
            if (!(await checkStock(btnItem))) { await i.reply({ content: `‚ùå [${btnItem.name}] ÌíàÏ†àÏûÖÎãàÎã§.`, ephemeral: true }); return; }
            if (userBuying[i.user.id]) { await i.reply({ content: 'Ïù¥ÎØ∏ Íµ¨Îß§ Ï≤òÎ¶¨ Ï§ëÏûÖÎãàÎã§. Ïû†ÏãúÎßå Í∏∞Îã§Î†§ Ï£ºÏÑ∏Ïöî!', ephemeral: true }); return; }
            userBuying[i.user.id] = true;
            try {
              const member = await i.guild.members.fetch(i.user.id);
              if (member.roles.cache.has(btnItem.roleId)) { await i.reply({ content: `Ïù¥ÎØ∏ [${btnItem.name}] Ïó≠Ìï†ÏùÑ ÏÜåÏú†ÌïòÍ≥† ÏûàÏñ¥Ïöî!`, ephemeral: true }); return; }
              const be = await loadJson(bePath);
              const userBeNow = be[i.user.id]?.amount || 0;
              if (userBeNow < btnItem.price) { await i.reply({ content: `ÌååÎûë Ï†ïÏàò Î∂ÄÏ°±! (Î≥¥Ïú†: ${numFmt(userBeNow)} BE)`, ephemeral: true }); return; }
              await decreaseStock(btnItem);
              const beBackup = JSON.stringify(be);
              be[i.user.id] = be[i.user.id] || { amount: 0, history: [] };
              be[i.user.id].amount -= btnItem.price;
              be[i.user.id].history.push({ type: "spend", amount: btnItem.price, reason: `${btnItem.name} Ïó≠Ìï† Íµ¨Îß§`, timestamp: Date.now() });
              await saveJson(bePath, be);
              try {
                await member.roles.add(btnItem.roleId, "Í∞ïÌôî ÏïÑÏù¥ÌÖú Íµ¨Îß§");
              } catch {
                await saveJson(bePath, JSON.parse(beBackup));
                await i.reply({ content: `‚ùå Ïó≠Ìï† ÏßÄÍ∏â Ïã§Ìå®! (Í∂åÌïú Î∂ÄÏ°± ÎòêÎäî ÏÑ§Ï†ï Ïò§Î•ò / BE Ï∞®Í∞ê Ï∑®ÏÜåÎê®)`, ephemeral: true });
                return;
              }
              await i.reply({ content: `‚úÖ [${btnItem.name}] Ïó≠Ìï†ÏùÑ ${numFmt(btnItem.price)} BEÏóê Íµ¨Îß§ ÏôÑÎ£å!`, ephemeral: true });
            } catch (e) {
              await i.reply({ content: `‚ùå Ïò§Î•ò Î∞úÏÉù: ${e.message}`, ephemeral: true });
            } finally { userBuying[i.user.id] = false; }
            return;
          }
        }

        if (state.view === 'item') {
          if (i.customId === "item_prev") {
            state.page = Math.max(0, state.page - 1);
            const payload = await renderItemShop(interaction.user.id, state.page, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId === "item_next") {
            state.page = state.page + 1;
            const payload = await renderItemShop(interaction.user.id, state.page, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId === "item_refresh") {
            const payload = await renderItemShop(interaction.user.id, state.page, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId.startsWith("item_buy_")) {
            if (userBuying[i.user.id]) { await i.reply({ content: 'Ïù¥ÎØ∏ Íµ¨Îß§ Ï≤òÎ¶¨ Ï§ëÏûÖÎãàÎã§. Ïû†ÏãúÎßå Í∏∞Îã§Î†§ Ï£ºÏÑ∏Ïöî!', ephemeral: true }); return; }
            userBuying[i.user.id] = true;
            try {
              const ITEMS = require('../utils/items.js');
              const ITEM_LIST = Object.values(ITEMS);
              const itemName = i.customId.replace("item_buy_", "");
              const item = ITEM_LIST.find(x => x.name === itemName);
              if (!item) { await i.reply({ content: "Ìï¥Îãπ ÏïÑÏù¥ÌÖúÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", ephemeral: true }); return; }
              const items = await loadJson(itemsPath);
              items[i.user.id] = items[i.user.id] || {};
              const myItem = items[i.user.id][item.name] || { count: 0, desc: item.desc };
              if (myItem.count >= 99) { await i.reply({ content: `ÏµúÎåÄ 99Í∞úÍπåÏßÄÎßå ÏÜåÏßÄÌï† Ïàò ÏûàÏäµÎãàÎã§. (Î≥¥Ïú†: ${myItem.count})`, ephemeral: true }); return; }
              const be = await loadJson(bePath);
              const userBeNow = be[i.user.id]?.amount || 0;
              if (userBeNow < item.price) { await i.reply({ content: `ÌååÎûë Ï†ïÏàò Î∂ÄÏ°±! (Î≥¥Ïú†: ${numFmt(userBeNow)} BE)`, ephemeral: true }); return; }
              be[i.user.id] = be[i.user.id] || { amount: 0, history: [] };
              be[i.user.id].amount -= item.price;
              be[i.user.id].history.push({ type: "spend", amount: item.price, reason: `${item.name} Íµ¨Îß§`, timestamp: Date.now() });
              await saveJson(bePath, be);
              myItem.count += 1;
              items[i.user.id][item.name] = myItem;
              await saveJson(itemsPath, items);
              await i.reply({ content: `‚úÖ [${item.name}]ÏùÑ(Î•º) ${numFmt(item.price)} BEÏóê Íµ¨Îß§ ÏôÑÎ£å! (ÏµúÎåÄ 99Í∞úÍπåÏßÄ ÏÜåÏßÄ Í∞ÄÎä•)`, ephemeral: true });
            } catch (e) {
              await i.reply({ content: `‚ùå Ïò§Î•ò Î∞úÏÉù: ${e.message}`, ephemeral: true });
            } finally { userBuying[i.user.id] = false; }
            return;
          }
        }

        if (state.view === 'skill') {
          if (i.customId === "skill_prev") {
            state.page = Math.max(0, state.page - 1);
            const payload = await renderSkillShop(interaction.user.id, state.page, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId === "skill_next") {
            state.page = state.page + 1;
            const payload = await renderSkillShop(interaction.user.id, state.page, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId === "skill_refresh") {
            const payload = await renderSkillShop(interaction.user.id, state.page, sessionExpireAt);
            await i.update(payload);
            return;
          }
          if (i.customId.startsWith("skill_buy_")) {
            if (userBuying[i.user.id]) { await i.reply({ content: 'Ïù¥ÎØ∏ Íµ¨Îß§ Ï≤òÎ¶¨ Ï§ëÏûÖÎãàÎã§. Ïû†ÏãúÎßå Í∏∞Îã§Î†§ Ï£ºÏÑ∏Ïöî!', ephemeral: true }); return; }
            userBuying[i.user.id] = true;
            try {
              const SKILLS = require('../utils/active-skills.js');
              const SKILL_LIST = Object.values(SKILLS);
              const skillName = i.customId.replace("skill_buy_", "");
              const skill = SKILL_LIST.find(x => x.name === skillName);
              if (!skill) { await i.reply({ content: "Ìï¥Îãπ Ïä§ÌÇ¨ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", ephemeral: true }); return; }
              const skills = await loadJson(skillsPath);
              const mySkills = skills[i.user.id] || {};
              if (mySkills[skill.name]) { await i.reply({ content: `Ïù¥ÎØ∏ [${skill.name}] Ïä§ÌÇ¨ÏùÑ ÏÜåÏú†ÌïòÍ≥† ÏûàÏäµÎãàÎã§! (Ïä§ÌÇ¨ÏùÄ 1Í∞úÎßå ÏÜåÏú† Í∞ÄÎä•)`, ephemeral: true }); return; }
              const be = await loadJson(bePath);
              const userBeNow = be[i.user.id]?.amount || 0;
              if (userBeNow < skill.price) { await i.reply({ content: `ÌååÎûë Ï†ïÏàò Î∂ÄÏ°±! (Î≥¥Ïú†: ${numFmt(userBeNow)} BE)`, ephemeral: true }); return; }
              be[i.user.id] = be[i.user.id] || { amount: 0, history: [] };
              be[i.user.id].amount -= skill.price;
              be[i.user.id].history.push({ type: "spend", amount: skill.price, reason: `${skill.name} Ïä§ÌÇ¨ Íµ¨Îß§`, timestamp: Date.now() });
              await saveJson(bePath, be);
              skills[i.user.id] = skills[i.user.id] || {};
              skills[i.user.id][skill.name] = { desc: skill.desc };
              await saveJson(skillsPath, skills);
              await i.reply({ content: `‚úÖ [${skill.name}] Ïä§ÌÇ¨ÏùÑ ${numFmt(skill.price)} BEÏóê Íµ¨Îß§ ÏôÑÎ£å! (ÎèôÏùº Ïä§ÌÇ¨ Ï§ëÎ≥µ Î≥¥Ïú† Î∂àÍ∞Ä)`, ephemeral: true });
            } catch (e) {
              await i.reply({ content: `‚ùå Ïò§Î•ò Î∞úÏÉù: ${e.message}`, ephemeral: true });
            } finally { userBuying[i.user.id] = false; }
            return;
          }
        }
      });

      collector.on('end', async () => {
        try { clearInterval(interval); } catch {}
        await cleanupSession(interaction.user.id);
      });
    } catch (err) {
      try { await interaction.editReply({ content: `‚ùå Ïò§Î•ò Î∞úÏÉù: ${err.message}` }); } catch {}
      try { await cleanupSession(interaction.user.id); } catch {}
    }
  }
};
