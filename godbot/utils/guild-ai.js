const fs = require("fs");
const path = require("path");
const { Events } = require("discord.js");

const DATA_DIR = path.join(__dirname, "data", "guild-ai");
const USERS_PATH = path.join(DATA_DIR, "users.json");
const MARKOV_DIR = path.join(DATA_DIR, "markov");

if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
if (!fs.existsSync(MARKOV_DIR)) fs.mkdirSync(MARKOV_DIR, { recursive: true });

function loadJsonSafe(file, fallback) {
  try { return fs.existsSync(file) ? JSON.parse(fs.readFileSync(file, "utf8")) : fallback; }
  catch { return fallback; }
}
function saveJsonSafe(file, obj) {
  try { fs.writeFileSync(file, JSON.stringify(obj, null, 2), "utf8"); } catch {}
}

const memory = {
  users: loadJsonSafe(USERS_PATH, {}),
  markovByUser: new Map(),
  markovGlobal: { order: 2, map: {}, tokensSeen: 0 },
  chatChannelId: null,
  lastReplyTsByChannel: new Map(),
  lastBotMsgByChannel: new Map(),
  convoByChannel: new Map(), // Ï±ÑÎÑêÎ≥Ñ ÏµúÍ∑º ÎåÄÌôî Ïä§ÌÉù
  lastComposerPatternByChannel: new Map(),
};

const URL_RE = /(https?:\/\/[^\s]+)/ig;
const EMOJI_RE = /([\u{1F300}-\u{1FAD6}\u{1F900}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}])/u;
const PUNC_RE = /([.!?‚Ä¶]+)|([,;:()"'`„Ää„Äã„Äà„Äâ„Äå„Äç„Äé„Äè„Äê„Äë\[\]{}])/g;
const SPLIT_RE = /\s+/;

function tokenize(text) {
  const replaced = text
    .replace(URL_RE, " __URL__ ")
    .replace(PUNC_RE, " $1$2 ")
    .replace(EMOJI_RE, " $1 ");
  return replaced.split(SPLIT_RE).map(t => t.trim()).filter(Boolean).slice(0, 400);
}
function koreanRate(text) {
  if (!text) return 0;
  let k = 0, n = 0;
  for (const ch of text) {
    const cp = ch.codePointAt(0);
    if ((cp >= 0xAC00 && cp <= 0xD7A3) || (cp >= 0x1100 && cp <= 0x11FF) || (cp >= 0x3130 && cp <= 0x318F)) k++;
    n++;
  }
  return n ? k / n : 0;
}

function getUserModel(id) {
  if (!memory.users[id]) {
    memory.users[id] = {
      id, firstSeen: Date.now(), lastSeen: Date.now(),
      messages: 0, tokens: 0, emojis: 0, questions: 0,
      positives: 0, negatives: 0, lastTopics: [], topWords: {},
      slangRate: 0.5, exclaimRate: 0.3,
      avgLen: 18,
    };
  }
  return memory.users[id];
}
function updateUserStats(user, text, toks) {
  user.lastSeen = Date.now();
  user.messages += 1;
  user.tokens += toks.length;
  user.avgLen = Math.max(8, Math.min(80, Math.round(user.avgLen * 0.9 + Math.min(60, toks.length) * 0.1)));
  if (/[?Ôºü]$/.test(text.trim())) user.questions += 1;
  if ((text.toLowerCase().match(/(„Öã„Öã+|„Öé„Öé+|„Ñπ„Öá|„Öá„Öá|„Ñ±„Ñ±|Í∞úÏ©î|„Ñ∑„Ñ∑)/g) || []).length) user.slangRate = user.slangRate * 0.85 + 0.15;
  if ((text.match(/[!ÔºÅ]+/g) || []).length) user.exclaimRate = user.exclaimRate * 0.85 + 0.15;
  user.emojis += (text.match(new RegExp(EMOJI_RE, "gu")) || []).length;

  const topics = toks
    .filter(t => !t.startsWith("__") && /[\p{L}\p{N}]/u.test(t) && koreanRate(t) >= 0.3 && t.length >= 2)
    .slice(0, 10);
  if (topics.length) {
    user.lastTopics = Array.from(new Set([...topics, ...user.lastTopics])).slice(0, 12);
    for (const t of topics) user.topWords[t] = (user.topWords[t] || 0) + 1;
    const top = Object.entries(user.topWords).sort((a,b)=>b[1]-a[1]).slice(0, 1000);
    user.topWords = Object.fromEntries(top);
  }
}

function loadMarkov(uid) {
  const f = path.join(MARKOV_DIR, `${uid}.json`);
  const data = loadJsonSafe(f, null);
  if (data && data.map && data.order === 2) return data;
  return { order: 2, map: {}, tokensSeen: 0 };
}
function saveMarkov(uid, data) { saveJsonSafe(path.join(MARKOV_DIR, `${uid}.json`), data); }

function getMarkov(uid) {
  if (!memory.markovByUser.has(uid)) memory.markovByUser.set(uid, loadMarkov(uid));
  return memory.markovByUser.get(uid);
}
function feedMarkov(model, toks) {
  for (let i = 0; i < toks.length - 2; i++) {
    const a = toks[i], b = toks[i+1], c = toks[i+2];
    const key = `${a}|${b}`;
    if (!model.map[key]) model.map[key] = {};
    model.map[key][c] = (model.map[key][c] || 0) + 1;
    model.tokensSeen++;
  }
  const keys = Object.keys(model.map);
  if (keys.length > 35000 || model.tokensSeen > 320000) {
    const trimmed = keys.slice(-Math.floor(keys.length * 0.6));
    const newMap = {};
    for (const k of trimmed) newMap[k] = model.map[k];
    model.map = newMap;
    model.tokensSeen = Math.floor(model.tokensSeen * 0.6);
  }
}
function weightedPick(obj, temperature = 1.0, banSet = null) {
  const entries = Object.entries(obj);
  if (!entries.length) return null;
  let sum = 0;
  const adjusted = entries.map(([k, v]) => {
    let w = v;
    if (banSet && banSet.has(k)) w *= 0.03;
    if (temperature !== 1.0) w = Math.pow(w, 1/Math.max(0.25, Math.min(2.0, temperature)));
    sum += w;
    return [k, w];
  });
  if (sum <= 0) return entries[0][0];
  let r = Math.random() * sum;
  for (const [k, w] of adjusted) {
    r -= w;
    if (r <= 0) return k;
  }
  return adjusted[0][0];
}
function pickSeed(model, seedTokens, banSet) {
  const keys = Object.keys(model.map);
  if (!keys.length) return null;
  if (seedTokens && seedTokens.length) {
    const cand = [];
    for (const key of keys) {
      const [a,b] = key.split("|");
      let score = 0;
      if (seedTokens.includes(a)) score++;
      if (seedTokens.includes(b)) score++;
      if (score) cand.push({ key, score });
    }
    if (cand.length) {
      cand.sort((x,y)=>y.score-x.score);
      const top = cand.slice(0, Math.min(80, cand.length));
      const chosen = top[Math.floor(Math.random()*top.length)].key.split("|");
      if (!banSet || (!banSet.has(chosen[0]) || !banSet.has(chosen[1]))) return chosen;
    }
  }
  return keys[Math.floor(Math.random()*keys.length)].split("|");
}
function detok(tokens) {
  const join = new Set([",",".","!","?","‚Ä¶",";",":",")","]","}","¬ª","‚Äù"]);
  const left = new Set(["(","[","{","¬´","‚Äú"]);
  const out = [];
  for (let i=0;i<tokens.length;i++){
    const t = tokens[i];
    if (t === "__URL__") { out.push("https://example.com"); continue; }
    if (i===0) { out.push(t); continue; }
    if (join.has(t)) out[out.length-1]+=t;
    else if (left.has(t)) out.push(t);
    else out.push(" "+t);
  }
  return out.join("").trim();
}
function gen(model, seedTokens, opts = {}) {
  const { maxLen = 48, temperature = 1.0, banSet = null } = opts;
  const keys = Object.keys(model.map);
  if (!keys.length) return null;
  const seed = pickSeed(model, seedTokens, banSet) || keys[Math.floor(Math.random()*keys.length)].split("|");
  let [a,b] = seed;
  const out = [a,b];
  for (let i=0;i<maxLen;i++){
    const key = `${a}|${b}`;
    const nextMap = model.map[key];
    if (!nextMap) break;
    const n = weightedPick(nextMap, temperature, banSet);
    if (!n) break;
    out.push(n);
    a = b; b = n;
    if (/[.!?‚Ä¶]/.test(n) && out.length > 10) break;
  }
  return detok(out);
}

function averageServerTone() {
  const users = Object.values(memory.users);
  if (!users.length) return { slang: 0.4, exclaim: 0.3, avgLen: 18 };
  const n = users.length;
  const slang = users.reduce((s,u)=>s+u.slangRate,0)/n;
  const exclaim = users.reduce((s,u)=>s+u.exclaimRate,0)/n;
  const avgLen = Math.max(12, Math.min(52, Math.round(users.reduce((s,u)=>s+u.avgLen,0)/n)));
  return { slang, exclaim, avgLen };
}
function postProcessTone(text) {
  const { slang, exclaim } = averageServerTone();
  let t = text;
  if (slang >= 0.6) t = t.replace(/\b(Ìï©ÎãàÎã§|ÏûÖÎãàÎã§)\b/g, "ÏûÑ");
  else t = t.replace(/\b(„ÖÖ„ÖÇ|Ïî®Î∞ú)\b/g, "ÏïÑÎÜî");
  if (exclaim >= 0.55 && !/[!ÔºÅ]$/.test(t)) { if (t.length < 60) t += "!"; }
  else if (exclaim < 0.25) { t = t.replace(/[!ÔºÅ]{2,}/g, "!"); }
  t = t.replace(/([„Öã„Öé])\1{4,}/g, "$1$1$1");

  // ÏÇ¥Ïßù Ïò®Í∏∞(Í≥ºÌïòÏßÄ ÏïäÍ≤å)
  if (t.length <= 28 && Math.random() < 0.25) {
    const soft = [" „Öé„Öé", " üôÇ", " üòâ", ""];
    t += soft[Math.floor(Math.random()*soft.length)];
  }
  // ÎßàÏπ®Ìëú ÏóÜÏù¥ ÎÅùÎÇòÎ©¥ Í∞ÑÎã®Ìûà Ï≤òÎ¶¨
  if (!/[.!?‚Ä¶!~]$/.test(t)) t += ".";
  return t;
}
function jaccard(aTokens, bTokens) {
  const A = new Set(aTokens);
  const B = new Set(bTokens);
  let inter = 0;
  for (const x of A) if (B.has(x)) inter++;
  const uni = A.size + B.size - inter || 1;
  return inter / uni;
}
function longestCommonRunLen(a, b) {
  let max = 0;
  for (let i=0;i<a.length;i++){
    for (let j=0;j<b.length;j++){
      let k=0;
      while (i+k<a.length && j+k<b.length && a[i+k]===b[j+k]) k++;
      if (k > max) max = k;
      if (max >= 3) return max;
    }
  }
  return max;
}
function antiEchoFilter(userText, draft) {
  const ut = tokenize(userText.toLowerCase()).slice(0, 100);
  const dt = tokenize(draft.toLowerCase()).slice(0, 100);
  const jac = jaccard(ut, dt);
  const lcr = longestCommonRunLen(ut, dt);
  return (jac < 0.35 && lcr < 3);
}
function diversify(line) {
  // Í≥ºÌïú Î†àÏù¥Î∏î/Íº¨Î¶¨Ìëú ÏóÜÏù¥ ÎßàÏπ®Îßå Ï†ïÎ¶¨
  let t = line;
  if (!/[.?!‚Ä¶!]$/.test(t)) t += ".";
  return t;
}

function isSensitiveAsk(s) {
  const lower = s.toLowerCase();
  const kw = [
    "token","ÌÜ†ÌÅ∞","env","ÌôòÍ≤ΩÎ≥ÄÏàò","ÎπÑÎ∞ÄÎ≤àÌò∏","password","secret","key","ÌÇ§Í∞í","role id","Ïó≠Ìï†id","Í∂åÌïú",
    "Í∂åÌïúÏäπÍ≤©","administrator","Í¥ÄÎ¶¨Ïûê Í∂åÌïú","internal","ÎÇ¥Î∂Ä","db","database","supabase","railway","github",
    "config","ÏÑ§Ï†ïÌååÏùº","Î°úÍ∑∏","log","Ï±ÑÎÑêid","Ï±ÑÎÑê id","id ÏïåÎ†§","Ïä¨ÎûòÏãú Î™ÖÎ†πÏñ¥ Îì±Î°ù","eval","Ïû¨ÏãúÏûë","Í∫º",
    "ÏÑúÎ≤Ñ Í∏∞Î∞Ä","secret","Î≥¥Ïïà","ÌÜ†ÌÅ∞ Î≥¥Ïó¨","ÏÜåÏä§ÏΩîÎìú","Î™ÖÎ†πÏñ¥","ÏßÄÏãúÌï¥","ÏÑ§Ï†ï Î∞îÍøî","Í∂åÌïú Ï§ò","Ïó≠Ìï† Ï§ò",
  ];
  return kw.some(k => lower.includes(k));
}

function pushConvo(channelId, role, text) {
  const key = String(channelId);
  if (!memory.convoByChannel.has(key)) memory.convoByChannel.set(key, []);
  const arr = memory.convoByChannel.get(key);
  arr.push({ role, text: (text||"").slice(0, 800) });
  if (arr.length > 12) arr.shift();
}

function topKeywordsGlobal(k = 3) {
  const bag = Object.values(memory.users).reduce((acc, u) => {
    for (const [w,c] of Object.entries(u.topWords)) acc[w]=(acc[w]||0)+c;
    return acc;
  }, {});
  return Object.entries(bag).sort((a,b)=>b[1]-a[1]).slice(0,k).map(([w])=>w);
}

function craftReply(authorId, prompt, channelId) {
  const convo = memory.convoByChannel.get(String(channelId)) || [];
  const historyTokens = tokenize(convo.map(x=>x.text).join(" ").toLowerCase()).filter(w=>koreanRate(w)>=0.25).slice(-60);
  const userSeed = tokenize(prompt).filter(w => koreanRate(w) >= 0.25).slice(0, 40);
  const seed = Array.from(new Set([...userSeed, ...historyTokens]));
  const banSet = new Set(seed.slice(0, 30));

  let line =
    gen(getMarkov(authorId), seed, { maxLen: 46, temperature: 1.25, banSet: banSet }) ||
    gen(memory.markovGlobal, seed, { maxLen: 50, temperature: 1.15, banSet: banSet });

  if (!line) {
    const others = Object.keys(memory.users).filter(id => id !== authorId);
    if (others.length) {
      const pick = others[Math.floor(Math.random()*others.length)];
      line = gen(getMarkov(pick), seed, { maxLen: 44, temperature: 1.2, banSet: banSet });
    }
  }
  if (!line) line = "ÏïåÍ≤†Ïñ¥.";

  let tries = 0;
  while (!antiEchoFilter(prompt, line) && tries < 5) {
    const confuse = ["Í∑ºÎç∞", "ÏÜîÏßÅÌûà", "Î∞òÎåÄÎ°ú", "ÏïÑÎ¨¥Ìäº", "Í≤∞Î°†Ï†ÅÏúºÎ°ú", "ÌïúÌé∏"];
    const alt =
      gen(memory.markovGlobal, [], { maxLen: 44, temperature: 1.55, banSet: banSet }) ||
      gen(memory.markovGlobal, confuse, { maxLen: 42, temperature: 1.45, banSet: banSet });
    if (alt && antiEchoFilter(prompt, alt)) { line = alt; break; }
    tries++;
    if (tries >= 5) { line = "ÏïåÍ≤†Ïñ¥."; break; }
  }

  line = postProcessTone(line);
  line = diversify(line);
  return line;
}

function maybeFollowUp(authorModel) {
  // ÏûêÏó∞Ïä§Îü¨Ïö¥ ÏßßÏùÄ Íº¨Î¶¨ÎßêÎßå Í∞ÄÎÅî
  const base = [
    "ÎßûÏßÄ?", "Í∑∏Î†áÍ≤å Î≥¥Îäî Í≤å ÎÇ´ÎÇò", "ÏöîÍ±¥ ÎÑ§ ÏÉùÍ∞ÅÏù¥ Í∂ÅÍ∏àÌï®",
    "Ìè¨Ïù∏Ìä∏Îäî Î≠êÎ°ú Ïû°ÏùÑÍπå", "ÌïµÏã¨ Ìïú Ï§ÑÎ°ú Î≠êÏïº", "Ïù¥ Ï†ïÎèÑÎ©¥ ÏñºÏ∂î Ï†ïÎ¶¨Îê®"
  ];
  const qRate = (authorModel.questions / Math.max(1, authorModel.messages));
  const p = Math.min(0.22, 0.04 + qRate * 0.6);
  return (Math.random() < p) ? base[Math.floor(Math.random()*base.length)] : null;
}

function composeFinal(authorId, prompt, channelId) {
  const u = getUserModel(authorId);
  const avg = averageServerTone();

  // 1) Í∏∞Î≥∏ Î¨∏Ïû• ÏÉùÏÑ±
  const base = craftReply(authorId, prompt, channelId) || "ÏïåÍ≤†Ïñ¥.";

  // 2) ÌÇ§ÏõåÎìú Ïä§ÌååÏù¥Ïä§: Í¥ÑÌò∏ ÏóÜÏù¥ ÏûêÏó∞ ÏÇΩÏûÖ
  const kw = topKeywordsGlobal(3);
  const spiceLine = (kw.length && Math.random() < 0.35)
    ? ` ÏöîÏ¶ò ${kw[0]} ÏñòÍ∏∞ÎèÑ Ï¢ÖÏ¢Ö ÎÇòÏò§ÎçîÎùº`
    : "";

  // 3) ÎßêÌà¨ ÌÖúÌîåÎ¶ø (ÎùºÎ≤®/Í¥ÑÌò∏ Í∏àÏßÄ)
  const openers = ["Ïò§ÏºÄÏù¥, ", "Ìù†, ", "Ïùå‚Ä¶ ", "Ï¢ãÏïÑ. ", ""];
  const endings = ["", "", "", " Í∑∏Ïπò.", " ÎßûÏïÑ.", " Ïã∂ÎÑ§."];

  const opener = openers[Math.floor(Math.random()*openers.length)];
  const ending = endings[Math.floor(Math.random()*endings.length)];

  // 4) follow-upÏùÄ Ìïú Î¨∏Ïû• Îí§ ÏûêÏó∞ Ïó∞Í≤∞
  const fu = maybeFollowUp(u);
  const tail = fu ? ` ${fu}` : "";

  // 5) Í∏∏Ïù¥ Ï°∞Ï†à
  let final = `${opener}${base}${spiceLine}${ending}${tail}`.trim();
  const targetLen = Math.max(14, Math.min(58, Math.round((u.avgLen + avg.avgLen) / 2)));
  if (tokenize(final).length < targetLen && Math.random() < 0.42) {
    const extra = craftReply(authorId, prompt + " (Îã§Î•∏ Í∞ÅÎèÑ)", channelId);
    if (antiEchoFilter(final, extra)) {
      final = `${final} Îòê, ${extra.replace(/^Îòê[, ]?/,"")}`.trim();
    }
  }

  // 6) Î†àÏù¥Î∏î/Í¥ÑÌò∏Ï≤¥ Í∞ïÏ†ú Ï†úÍ±∞
  final = final
    .replace(/^\s*Ìïú\s*Ï§Ñ\s*ÏöîÏïΩ\s*:\s*/gi, "")
    .replace(/\([\s\S]{0,24}Í¥ÄÏ†êÎèÑ ÏûàÏùå\)/gi, "")
    .replace(/\s*,\s*\(.*?\/.*?\)/g, "");

  return postProcessTone(final);
}

function register(client, { chatChannelId }) {
  memory.chatChannelId = String(chatChannelId || "");

  client.on(Events.MessageCreate, async (msg) => {
    try {
      if (!msg.guild || msg.author.bot) return;
      const raw = (msg.content || "");
      if (!raw || raw.length > 4000) return;
      const codeBlockCount = (raw.match(/```/g) || []).length;
      if (codeBlockCount >= 2) return;

      const toks = tokenize(raw);
      if (toks.length >= 3) {
        const u = getUserModel(msg.author.id);
        updateUserStats(u, raw, toks);
        feedMarkov(getMarkov(msg.author.id), toks);
        feedMarkov(memory.markovGlobal, toks);
        if (Math.random() < 0.05) {
          saveJsonSafe(USERS_PATH, memory.users);
          saveMarkov(msg.author.id, getMarkov(msg.author.id));
        }
      }

      if (memory.chatChannelId && msg.channel.id === memory.chatChannelId) {
        pushConvo(msg.channel.id, "user", raw);
      }
    } catch {}
  });

  client.on(Events.MessageCreate, async (msg) => {
    try {
      if (!msg.guild || msg.author.bot) return;
      if (!memory.chatChannelId || msg.channel.id !== memory.chatChannelId) return;

      const content = (msg.content || "").trim();
      if (!content) return;
      if (isSensitiveAsk(content)) {
        pushConvo(msg.channel.id, "assistant", "Í∑∏Í±¥ Ïó¨Í∏∞ÏÑú Îã§Î£®Í∏∞ Í≥§ÎûÄÌï®. ÎåÄÌôîÎßå ÌïòÏûê.");
        return void msg.channel.send("Í∑∏Í±¥ Ïó¨Í∏∞ÏÑú Îã§Î£®Í∏∞ Í≥§ÎûÄÌï®. ÎåÄÌôîÎßå ÌïòÏûê.");
      }

      const lastTs = memory.lastReplyTsByChannel.get(msg.channel.id) || 0;
      if (Date.now() - lastTs < 1800) return;
      memory.lastReplyTsByChannel.set(msg.channel.id, Date.now());

      const lastBot = memory.lastBotMsgByChannel.get(msg.channel.id) || "";
      let finalText = composeFinal(msg.author.id, content, msg.channel.id);

      let tries = 0;
      while (lastBot && !antiEchoFilter(lastBot, finalText) && tries < 3) {
        const alt = composeFinal(msg.author.id, content + " (Îã§Î•∏ Í¥ÄÏ†ê)", msg.channel.id);
        if (antiEchoFilter(lastBot, alt)) { finalText = alt; break; }
        tries++;
      }
      // Í¥ÑÌò∏ Î©òÌä∏ ÎçßÎ∂ôÏù¥ÏßÄ ÏïäÏùå

      memory.lastBotMsgByChannel.set(msg.channel.id, finalText);
      pushConvo(msg.channel.id, "assistant", finalText);
      await msg.channel.send(finalText);

      // Î≥ÑÎèÑÏùò 'ÏöîÏ¶ò Ìï´:' Îã®Î∞ú Î©îÏãúÏßÄÎäî ÎπÑÌôúÏÑ±Ìôî
      // if (Math.random() < 0.10) {
      //   const top = Object.entries(
      //     Object.values(memory.users).reduce((acc, u) => {
      //       for (const [w,c] of Object.entries(u.topWords)) acc[w]=(acc[w]||0)+c;
      //       return acc;
      //     }, {})
      //   ).sort((a,b)=>b[1]-a[1]).slice(0,3).map(([w])=>w);
      //   if (top.length) {
      //     const brief = `ÏöîÏ¶ò Ìï´: ${top.join(" ‚Ä¢ ")}`;
      //     memory.lastBotMsgByChannel.set(msg.channel.id, brief);
      //     pushConvo(msg.channel.id, "assistant", brief);
      //     await msg.channel.send(brief);
      //   }
      // }
    } catch {}
  });

  setInterval(() => {
    try {
      saveJsonSafe(USERS_PATH, memory.users);
      const hot = Object.entries(memory.users).sort((a,b)=>b[1].messages-a[1].messages).slice(0,3).map(([id])=>id);
      for (const id of hot) saveMarkov(id, getMarkov(id));
      saveJsonSafe(path.join(MARKOV_DIR, "_global.json"), memory.markovGlobal);
    } catch {}
  }, 60_000);
}

module.exports = { register };
